package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"reflect"
	"runtime"
	"strings"
)

type Generator struct {
	io.Writer
	outbuf bytes.Buffer
	out    io.Writer

	Disasm    bytes.Buffer
	GenDisasm bool

	opDedeup      map[string]int
	opMapping     map[int]int
	disasmDedup   map[string]int
	disasmMapping map[int]int
}

func (g *Generator) writeHeader() {
	fmt.Fprintf(g, "// Code generated by cpugen/gen_nes6502.go. DO NOT EDIT.\n")
	fmt.Fprintf(g, "package emu\n")
	if g.GenDisasm {
		fmt.Fprintf(g, "import \"bytes\"\n")
		fmt.Fprintf(g, "import \"strconv\"\n")
	}
}

func funcname(temp any) string {
	strs := strings.Split((runtime.FuncForPC(reflect.ValueOf(temp).Pointer()).Name()), ".")
	return strs[len(strs)-1]
}

func (g *Generator) opcodeHeader(code int, f func(*Generator)) {
	fmt.Fprintf(g, "// %s\n", funcname(f))
	fmt.Fprintf(g, "func opcode_%02X(cpu*CPU){\n", code)
}

func (g *Generator) opcodeFooter() {
	fmt.Fprintf(g, "}\n")
}

// Addressing mode generators
type addrmode func(g *Generator)

func zp(g *Generator) {
	fmt.Fprintf(g, "// zero page addressing\n")
	fmt.Fprintf(g, "addr := cpu.Read8(cpu.PC)\n")
	fmt.Fprintf(g, "cpu.PC++\n")
	fmt.Fprintf(g, "oper := uint16(addr)\n")
}

func izx(g *Generator) {
	fmt.Fprintf(g, "// indexed addressing (abs, X)\n")
	fmt.Fprintf(g, "cpu.tick()\n")
	fmt.Fprintf(g, "op_ := cpu.Read8(cpu.PC)\n")
	fmt.Fprintf(g, "cpu.PC++\n")
	fmt.Fprintf(g, "addr := uint16(uint8(op_) + cpu.X)\n")
	fmt.Fprintf(g, "lo := cpu.Read8(addr)\n")
	fmt.Fprintf(g, "hi := cpu.Read8(uint16(uint8(addr) + 1))\n")
	fmt.Fprintf(g, "oper := uint16(hi)<<8 | uint16(lo)\n")
}

func BRK(g *Generator) {
	fmt.Fprintf(g, "cpu.tick()\n")
	fmt.Fprintf(g, "push16(cpu, cpu.PC+1)\n")
	fmt.Fprintf(g, "p := cpu.P\n")
	fmt.Fprintf(g, "p.setBit(pbitB)\n")
	fmt.Fprintf(g, "push8(cpu, uint8(p))\n")
	fmt.Fprintf(g, "cpu.P.setBit(pbitI)\n")
	fmt.Fprintf(g, "cpu.PC = cpu.Read16(IRQvector)\n")
}

func ORA(m addrmode) func(*Generator) {
	return func(g *Generator) {
		m(g)
		fmt.Fprintf(g, "// ORA\n")
		fmt.Fprintf(g, "val := cpu.Read8(oper)\n")
		fmt.Fprintf(g, "cpu.A |= val\n")
		fmt.Fprintf(g, "cpu.P.checkNZ(cpu.A)\n")
	}
}

func (g *Generator) writeOps() {
	var ops = [256]func(*Generator){
		0x00: BRK,
		0x01: ORA(izx),
		0x05: ORA(zp),
		/*
			0x01: ORA("izx"),
			0x02: JAM,
			0x03: SLO("izx"),
			0x04: NOP("zp"),
			0x05: ORA("zp"),
			0x06: ASL("zp"),
			0x07: SLO("zp"),
			0x08: PHP,
			0x09: ORA("imm"),
			0x0A: ASL("acc"),
			0x0B: ANC,
			0x0C: NOP("abs"),
			0x0D: ORA("abs"),
			0x0E: ASL("abs"),
			0x0F: SLO("abs"),
			0x10: branch(pbitN, false),
			0x11: ORA("izy_xp"),
			0x12: JAM,
			0x13: SLO("izy_xt"),
			0x14: NOP("zpx"),
			0x15: ORA("zpx"),
			0x16: ASL("zpx"),
			0x17: SLO("zpx"),
			0x18: CL(pbitC),
			0x19: ORA("aby_xp"),
			0x1A: NOPimp,
			0x1B: SLO("aby"),
			0x1C: NOP("abx_xp"),
			0x1D: ORA("abx_xp"),
			0x1E: ASL("abx"),
			0x1F: SLO("abx"),
			0x20: JSR,
			0x21: AND("izx"),
			0x22: JAM,
			0x23: RLA("izx"),
			0x24: BIT("zp"),
			0x25: AND("zp"),
			0x26: ROL("zp"),
			0x27: RLA("zp"),
			0x28: PLP,
			0x29: AND("imm"),
			0x2A: ROL("acc"),
			0x2B: ANC,
			0x2C: BIT("abs"),
			0x2D: AND("abs"),
			0x2E: ROL("abs"),
			0x2F: RLA("abs"),
			0x30: branch(pbitN, true),
			0x31: AND("izy_xp"),
			0x32: JAM,
			0x33: RLA("izy_xt"),
			0x34: NOP("zpx"),
			0x35: AND("zpx"),
			0x36: ROL("zpx"),
			0x37: RLA("zpx"),
			0x38: SE(pbitC),
			0x39: AND("aby_xp"),
			0x3A: NOPimp,
			0x3B: RLA("aby"),
			0x3C: NOP("abx_xp"),
			0x3D: AND("abx_xp"),
			0x3E: ROL("abx"),
			0x3F: RLA("abx"),
			0x40: RTI,
			0x41: EOR("izx"),
			0x42: JAM,
			0x43: SRE("izx"),
			0x44: NOP("zp"),
			0x45: EOR("zp"),
			0x46: LSR("zp"),
			0x47: SRE("zp"),
			0x48: PHA,
			0x49: EOR("imm"),
			0x4A: LSR("acc"),
			0x4B: ALR,
			0x4C: JMP("abs"),
			0x4D: EOR("abs"),
			0x4E: LSR("abs"),
			0x4F: SRE("abs"),
			0x50: branch(pbitV, false),
			0x51: EOR("izy_xp"),
			0x52: JAM,
			0x53: SRE("izy_xt"),
			0x54: NOP("zpx"),
			0x55: EOR("zpx"),
			0x56: LSR("zpx"),
			0x57: SRE("zpx"),
			0x58: CL(pbitI),
			0x59: EOR("aby_xp"),
			0x5A: NOPimp,
			0x5B: SRE("aby"),
			0x5C: NOP("abx_xp"),
			0x5D: EOR("abx_xp"),
			0x5E: LSR("abx"),
			0x5F: SRE("abx"),
			0x60: RTS,
			0x61: ADC("izx"),
			0x62: JAM,
			0x63: RRA("izx"),
			0x64: NOP("zp"),
			0x65: ADC("zp"),
			0x66: ROR("zp"),
			0x67: RRA("zp"),
			0x68: PLA,
			0x69: ADC("imm"),
			0x6A: ROR("acc"),
			0x6B: ARR,
			0x6C: JMPind,
			0x6D: ADC("abs"),
			0x6E: ROR("abs"),
			0x6F: RRA("abs"),
			0x70: branch(pbitV, true),
			0x71: ADC("izy_xp"),
			0x72: JAM,
			0x73: RRA("izy_xt"),
			0x74: NOP("zpx"),
			0x75: ADC("zpx"),
			0x76: ROR("zpx"),
			0x77: RRA("zpx"),
			0x78: SE(pbitI),
			0x79: ADC("aby_xp"),
			0x7A: NOPimp,
			0x7B: RRA("aby"),
			0x7C: NOP("abx_xp"),
			0x7D: ADC("abx_xp"),
			0x7E: ROR("abx"),
			0x7F: RRA("abx"),
			0x80: NOP("imm"),
			0x81: STA("izx"),
			0x82: NOP("imm"),
			0x83: SAX("izx"),
			0x84: STY("zp"),
			0x85: STA("zp"),
			0x86: STX("zp"),
			0x87: SAX("zp"),
			0x88: DEY,
			0x89: NOP("imm"),
			0x8A: TXA,
			0x8B: unsupported,
			0x8C: STY("abs"),
			0x8D: STA("abs"),
			0x8E: STX("abs"),
			0x8F: SAX("abs"),
			0x90: branch(pbitC, false),
			0x91: STA("izy_xt"),
			0x92: JAM,
			0x93: unsupported,
			0x94: STY("zpx"),
			0x95: STA("zpx"),
			0x96: STX("zpy"),
			0x97: SAX("zpy"),
			0x98: TYA,
			0x99: STA("aby"),
			0x9A: TXS,
			0x9B: unsupported,
			0x9C: SHY,
			0x9D: STA("abx"),
			0x9E: SHX,
			0x9F: unsupported,
			0xA0: LDY("imm"),
			0xA1: LDA("izx"),
			0xA2: LDX("imm"),
			0xA3: LAX("izx"),
			0xA4: LDY("zp"),
			0xA5: LDA("zp"),
			0xA6: LDX("zp"),
			0xA7: LAX("zp"),
			0xA8: TAY,
			0xA9: LDA("imm"),
			0xAA: TAX,
			0xAB: unsupported,
			0xAC: LDY("abs"),
			0xAD: LDA("abs"),
			0xAE: LDX("abs"),
			0xAF: LAX("abs"),
			0xB0: branch(pbitC, true),
			0xB1: LDA("izy_xp"),
			0xB2: JAM,
			0xB3: LAX("izy_xp"),
			0xB4: LDY("zpx"),
			0xB5: LDA("zpx"),
			0xB6: LDX("zpy"),
			0xB7: LAX("zpy"),
			0xB8: CL(pbitV),
			0xB9: LDA("aby_xp"),
			0xBA: TSX,
			0xBB: LAS,
			0xBC: LDY("abx_xp"),
			0xBD: LDA("abx_xp"),
			0xBE: LDX("aby_xp"),
			0xBF: LAX("aby_xp"),
			0xC0: CPY("imm"),
			0xC1: CMP("izx"),
			0xC2: NOP("imm"),
			0xC3: DCP("izx"),
			0xC4: CPY("zp"),
			0xC5: CMP("zp"),
			0xC6: DEC("zp"),
			0xC7: DCP("zp"),
			0xC8: INY,
			0xC9: CMP("imm"),
			0xCA: DEX,
			0xCB: SBX,
			0xCC: CPY("abs"),
			0xCD: CMP("abs"),
			0xCE: DEC("abs"),
			0xCF: DCP("abs"),
			0xD0: branch(pbitZ, false),
			0xD1: CMP("izy_xp"),
			0xD2: JAM,
			0xD3: DCPizy,
			0xD4: NOP("zpx"),
			0xD5: CMP("zpx"),
			0xD6: DEC("zpx"),
			0xD7: DCP("zpx"),
			0xD8: CL(pbitD),
			0xD9: CMP("aby_xp"),
			0xDA: NOPimp,
			0xDB: DCP("aby"),
			0xDC: NOP("abx_xp"),
			0xDD: CMP("abx_xp"),
			0xDE: DEC("abx"),
			0xDF: DCP("abx"),
			0xE0: CPX("imm"),
			0xE1: SBC("izx"),
			0xE2: NOP("imm"),
			0xE3: ISB("izx"),
			0xE4: CPX("zp"),
			0xE5: SBC("zp"),
			0xE6: INC("zp"),
			0xE7: ISB("zp"),
			0xE8: INX,
			0xE9: SBC("imm"),
			0xEA: NOPimp,
			0xEB: SBC("imm"),
			0xEC: CPX("abs"),
			0xED: SBC("abs"),
			0xEE: INC("abs"),
			0xEF: ISB("abs"),
			0xF0: branch(pbitZ, true),
			0xF1: SBC("izy_xp"),
			0xF2: JAM,
			0xF3: ISB("izy_xt"),
			0xF4: NOP("zpx"),
			0xF5: SBC("zpx"),
			0xF6: INC("zpx"),
			0xF7: ISB("zpx"),
			0xF8: SE(pbitD),
			0xF9: SBC("aby_xp"),
			0xFA: NOPimp,
			0xFB: ISB("aby"),
			0xFC: NOP("abx_xp"),
			0xFD: SBC("abx_xp"),
			0xFE: INC("abx"),
			0xFF: ISB("abx"),
		*/
	}

	for opc, op := range ops {
		if op == nil {
			// panic()
			continue
		}

		g.opcodeHeader(opc, op)
		op(g)
		g.opcodeFooter()
	}
}

func main() {
	log.SetFlags(0)
	outf := flag.String("out", "cpu_ops.go", "output file")
	flag.Parse()

	bb := &bytes.Buffer{}
	gen := Generator{
		Writer: bb,
	}

	gen.writeHeader()
	gen.writeOps()

	buf, err := format.Source(bb.Bytes())
	if err != nil {
		if err := os.WriteFile(*outf, bb.Bytes(), 0644); err != nil {
			fatalf("can't write to %s: %s", *outf, err)
		}
		fatalf("'gofmt' failed\n%s", err)
	}

	if err := os.WriteFile(*outf, buf, 0644); err != nil {
		fatalf("can't write to %s: %s", *outf, err)
	}
}

func fatalf(format string, args ...any) {
	fmt.Fprintf(os.Stderr, "fatal error:")
	fmt.Fprintf(os.Stderr, "\n\t%s\n", fmt.Sprintf(format, args...))
	os.Exit(1)
}
