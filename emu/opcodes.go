// Code generated by cpugen/gen_nes6502.go. DO NOT EDIT.
package emu

import (
	"fmt"
)

var ops = [256]func(*CPU){
	opcode00, opcode01, opcode02, opcode03, opcode04, opcode05, opcode06, opcode07, opcode08, opcode09, opcode0A, opcode0B, opcode0C, opcode0D, opcode0E, opcode0F,
	opcode10, opcode11, opcode12, opcode13, opcode14, opcode15, opcode16, opcode17, opcode18, opcode19, opcode1A, opcode1B, opcode1C, opcode1D, opcode1E, opcode1F,
	opcode20, opcode21, opcode22, opcode23, opcode24, opcode25, opcode26, opcode27, opcode28, opcode29, opcode2A, opcode2B, opcode2C, opcode2D, opcode2E, opcode2F,
	opcode30, opcode31, opcode32, opcode33, opcode34, opcode35, opcode36, opcode37, opcode38, opcode39, opcode3A, opcode3B, opcode3C, opcode3D, opcode3E, opcode3F,
	opcode40, opcode41, opcode42, opcode43, opcode44, opcode45, opcode46, opcode47, opcode48, opcode49, opcode4A, opcode4B, opcode4C, opcode4D, opcode4E, opcode4F,
	opcode50, opcode51, opcode52, opcode53, opcode54, opcode55, opcode56, opcode57, opcode58, opcode59, opcode5A, opcode5B, opcode5C, opcode5D, opcode5E, opcode5F,
	opcode60, opcode61, opcode62, opcode63, opcode64, opcode65, opcode66, opcode67, opcode68, opcode69, opcode6A, opcode6B, opcode6C, opcode6D, opcode6E, opcode6F,
	opcode70, opcode71, opcode72, opcode73, opcode74, opcode75, opcode76, opcode77, opcode78, opcode79, opcode7A, opcode7B, opcode7C, opcode7D, opcode7E, opcode7F,
	opcode80, opcode81, opcode82, opcode83, opcode84, opcode85, opcode86, opcode87, opcode88, opcode89, opcode8A, opcode8B, opcode8C, opcode8D, opcode8E, opcode8F,
	opcode90, opcode91, opcode92, opcode93, opcode94, opcode95, opcode96, opcode97, opcode98, opcode99, opcode9A, opcode9B, opcode9C, opcode9D, opcode9E, opcode9F,
	opcodeA0, opcodeA1, opcodeA2, opcodeA3, opcodeA4, opcodeA5, opcodeA6, opcodeA7, opcodeA8, opcodeA9, opcodeAA, opcodeAB, opcodeAC, opcodeAD, opcodeAE, opcodeAF,
	opcodeB0, opcodeB1, opcodeB2, opcodeB3, opcodeB4, opcodeB5, opcodeB6, opcodeB7, opcodeB8, opcodeB9, opcodeBA, opcodeBB, opcodeBC, opcodeBD, opcodeBE, opcodeBF,
	opcodeC0, opcodeC1, opcodeC2, opcodeC3, opcodeC4, opcodeC5, opcodeC6, opcodeC7, opcodeC8, opcodeC9, opcodeCA, opcodeCB, opcodeCC, opcodeCD, opcodeCE, opcodeCF,
	opcodeD0, opcodeD1, opcodeD2, opcodeD3, opcodeD4, opcodeD5, opcodeD6, opcodeD7, opcodeD8, opcodeD9, opcodeDA, opcodeDB, opcodeDC, opcodeDD, opcodeDE, opcodeDF,
	opcodeE0, opcodeE1, opcodeE2, opcodeE3, opcodeE4, opcodeE5, opcodeE6, opcodeE7, opcodeE8, opcodeE9, opcodeEA, opcodeEB, opcodeEC, opcodeED, opcodeEE, opcodeEF,
	opcodeF0, opcodeF1, opcodeF2, opcodeF3, opcodeF4, opcodeF5, opcodeF6, opcodeF7, opcodeF8, opcodeF9, opcodeFA, opcodeFB, opcodeFC, opcodeFD, opcodeFE, opcodeFF,
}

// BRK   00
// implied addressing.
func opcode00(cpu *CPU) {
	cpu.tick()
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) >> 8)))
		cpu.SP -= 1
	}
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) & 0xFF)))
		cpu.SP -= 1
	}
	p := cpu.P
	p.setBit(pbitB)
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8(p)))
		cpu.SP -= 1
	}
	cpu.P.setBit(pbitI)
	cpu.PC = cpu.Read16(IRQvector)
}

// ORA   01
// indexed addressing (abs, X).
func opcode01(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   02
// immediate addressing.
func opcode02(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SLO   03
// indexed addressing (abs, X).
func opcode03(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   04
// zero page addressing.
func opcode04(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

// ORA   05
// zero page addressing.
func opcode05(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   06
// zero page addressing.
func opcode06(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   07
// zero page addressing.
func opcode07(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PHP   08
// implied addressing.
func opcode08(cpu *CPU) {
	cpu.tick()
	p := cpu.P
	p |= (1 << pbitB) | (1 << pbitU)
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8(p)))
		cpu.SP -= 1
	}
}

// ORA   09
// immediate addressing.
func opcode09(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   0A
// adressing accumulator.
func opcode0A(cpu *CPU) {
	val := cpu.A
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A = val
}

// ANC   0B
// immediate addressing.
func opcode0B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, cpu.P.N())
}

// NOP   0C
// absolute addressing.
func opcode0C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.tick()
}

// ORA   0D
// absolute addressing.
func opcode0D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   0E
// absolute addressing.
func opcode0E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   0F
// absolute addressing.
func opcode0F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BPL   10
// relative addressing.
func opcode10(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(7) == false {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// ORA   11
// indexed addressing (abs),Y.
func opcode11(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   12
// immediate addressing.
func opcode12(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SLO   13
// indexed addressing (abs),Y.
func opcode13(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   14
// indexed addressing: zeropage,X.
func opcode14(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// ORA   15
// indexed addressing: zeropage,X.
func opcode15(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   16
// indexed addressing: zeropage,X.
func opcode16(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   17
// indexed addressing: zeropage,X.
func opcode17(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// CLC   18
// implied addressing.
func opcode18(cpu *CPU) {
	cpu.P.clearBit(0)
	cpu.tick()
}

// ORA   19
// absolute indexed Y.
func opcode19(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// NOP   1A
// implied addressing.
func opcode1A(cpu *CPU) {
	cpu.tick()
}

// SLO   1B
// absolute indexed Y.
func opcode1B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   1C
// absolute indexed X.
func opcode1C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// ORA   1D
// absolute indexed X.
func opcode1D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   1E
// absolute indexed X.
func opcode1E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   1F
// absolute indexed X.
func opcode1F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// JSR   20
func opcode20(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.tick()
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) >> 8)))
		cpu.SP -= 1
	}
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) & 0xFF)))
		cpu.SP -= 1
	}
	cpu.PC = oper
}

// AND   21
// indexed addressing (abs, X).
func opcode21(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   22
// immediate addressing.
func opcode22(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RLA   23
// indexed addressing (abs, X).
func opcode23(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BIT   24
// zero page addressing.
func opcode24(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P &= 0b00111111
	cpu.P |= P(val & 0b11000000)
	cpu.P.checkZ(cpu.A & val)
}

// AND   25
// zero page addressing.
func opcode25(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   26
// zero page addressing.
func opcode26(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   27
// zero page addressing.
func opcode27(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PLP   28
// implied addressing.
func opcode28(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var p uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		p = cpu.Read8(top)
	}
	const mask = 0b11001111 // ignore B and U bits
	cpu.P = P(copybits(uint8(cpu.P), p, mask))
}

// AND   29
// immediate addressing.
func opcode29(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   2A
// adressing accumulator.
func opcode2A(cpu *CPU) {
	val := cpu.A
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A = val
}

// ANC   2B
// immediate addressing.
func opcode2B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, cpu.P.N())
}

// BIT   2C
// absolute addressing.
func opcode2C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P &= 0b00111111
	cpu.P |= P(val & 0b11000000)
	cpu.P.checkZ(cpu.A & val)
}

// AND   2D
// absolute addressing.
func opcode2D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   2E
// absolute addressing.
func opcode2E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   2F
// absolute addressing.
func opcode2F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BMI   30
// relative addressing.
func opcode30(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(7) == true {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// AND   31
// indexed addressing (abs),Y.
func opcode31(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   32
// immediate addressing.
func opcode32(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RLA   33
// indexed addressing (abs),Y.
func opcode33(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   34
// indexed addressing: zeropage,X.
func opcode34(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// AND   35
// indexed addressing: zeropage,X.
func opcode35(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   36
// indexed addressing: zeropage,X.
func opcode36(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   37
// indexed addressing: zeropage,X.
func opcode37(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// SEC   38
// implied addressing.
func opcode38(cpu *CPU) {
	cpu.P.setBit(0)
	cpu.tick()
}

// AND   39
// absolute indexed Y.
func opcode39(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// NOP   3A
// implied addressing.
func opcode3A(cpu *CPU) {
	cpu.tick()
}

// RLA   3B
// absolute indexed Y.
func opcode3B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   3C
// absolute indexed X.
func opcode3C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// AND   3D
// absolute indexed X.
func opcode3D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   3E
// absolute indexed X.
func opcode3E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   3F
// absolute indexed X.
func opcode3F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// RTI   40
// implied addressing.
func opcode40(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var p uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		p = cpu.Read8(top)
	}
	const mask = 0b11001111 // ignore B and U bits
	cpu.P = P(copybits(uint8(cpu.P), p, mask))
	var lo, hi uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		lo = cpu.Read8(top)
	}
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		hi = cpu.Read8(top)
	}
	cpu.PC = uint16(hi)<<8 | uint16(lo)
}

// EOR   41
// indexed addressing (abs, X).
func opcode41(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   42
// immediate addressing.
func opcode42(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SRE   43
// indexed addressing (abs, X).
func opcode43(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   44
// zero page addressing.
func opcode44(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

// EOR   45
// zero page addressing.
func opcode45(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   46
// zero page addressing.
func opcode46(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   47
// zero page addressing.
func opcode47(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PHA   48
// implied addressing.
func opcode48(cpu *CPU) {
	cpu.tick()
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (cpu.A))
		cpu.SP -= 1
	}
}

// EOR   49
// immediate addressing.
func opcode49(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   4A
// adressing accumulator.
func opcode4A(cpu *CPU) {
	val := cpu.A
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A = val
}

// ALR   4B
// immediate addressing.
func opcode4B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	// like and + lsr but saves one tick
	cpu.A &= val
	carry := cpu.A & 0x01 // carry is bit 0
	cpu.A >>= 1
	cpu.A &= 0x7f
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, carry != 0)
}

// JMP   4C
// absolute addressing.
func opcode4C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.PC = oper
}

// EOR   4D
// absolute addressing.
func opcode4D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   4E
// absolute addressing.
func opcode4E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   4F
// absolute addressing.
func opcode4F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BVC   50
// relative addressing.
func opcode50(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(6) == false {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// EOR   51
// indexed addressing (abs),Y.
func opcode51(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   52
// immediate addressing.
func opcode52(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SRE   53
// indexed addressing (abs),Y.
func opcode53(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   54
// indexed addressing: zeropage,X.
func opcode54(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// EOR   55
// indexed addressing: zeropage,X.
func opcode55(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   56
// indexed addressing: zeropage,X.
func opcode56(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   57
// indexed addressing: zeropage,X.
func opcode57(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// CLI   58
// implied addressing.
func opcode58(cpu *CPU) {
	cpu.P.clearBit(2)
	cpu.tick()
}

// EOR   59
// absolute indexed Y.
func opcode59(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// NOP   5A
// implied addressing.
func opcode5A(cpu *CPU) {
	cpu.tick()
}

// SRE   5B
// absolute indexed Y.
func opcode5B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   5C
// absolute indexed X.
func opcode5C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// EOR   5D
// absolute indexed X.
func opcode5D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   5E
// absolute indexed X.
func opcode5E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   5F
// absolute indexed X.
func opcode5F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// RTS   60
// implied addressing.
func opcode60(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var lo, hi uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		lo = cpu.Read8(top)
	}
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		hi = cpu.Read8(top)
	}
	cpu.PC = uint16(hi)<<8 | uint16(lo)
	cpu.PC++
	cpu.tick()
}

// ADC   61
// indexed addressing (abs, X).
func opcode61(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// JAM   62
// immediate addressing.
func opcode62(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RRA   63
// indexed addressing (abs, X).
func opcode63(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   64
// zero page addressing.
func opcode64(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

// ADC   65
// zero page addressing.
func opcode65(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   66
// zero page addressing.
func opcode66(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   67
// zero page addressing.
func opcode67(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PLA   68
// implied addressing.
func opcode68(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		cpu.A = cpu.Read8(top)
	}
	cpu.P.checkNZ(cpu.A)
}

// ADC   69
// immediate addressing.
func opcode69(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   6A
// adressing accumulator.
func opcode6A(cpu *CPU) {
	val := cpu.A
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A = val
}

// ARR   6B
// immediate addressing.
func opcode6B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.A >>= 1
	cpu.P.writeBit(pbitV, (cpu.A>>6)^(cpu.A>>5)&0x01 != 0)
	// bit 7 is set to prev carry
	if cpu.P.C() {
		cpu.A |= 1 << 7
	}
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, cpu.A&(1<<6) != 0)
}

// JMP   6C
// indirect addressing.
func opcode6C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	lo := cpu.Read8(oper)
	// 2 bytes address wrap around
	hi := cpu.Read8((0xff00 & oper) | (0x00ff & (oper + 1)))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.PC = oper
}

// ADC   6D
// absolute addressing.
func opcode6D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   6E
// absolute addressing.
func opcode6E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   6F
// absolute addressing.
func opcode6F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BVS   70
// relative addressing.
func opcode70(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(6) == true {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// ADC   71
// indexed addressing (abs),Y.
func opcode71(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// JAM   72
// immediate addressing.
func opcode72(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RRA   73
// indexed addressing (abs),Y.
func opcode73(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   74
// indexed addressing: zeropage,X.
func opcode74(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// ADC   75
// indexed addressing: zeropage,X.
func opcode75(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   76
// indexed addressing: zeropage,X.
func opcode76(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   77
// indexed addressing: zeropage,X.
func opcode77(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// SEI   78
// implied addressing.
func opcode78(cpu *CPU) {
	cpu.P.setBit(2)
	cpu.tick()
}

// ADC   79
// absolute indexed Y.
func opcode79(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// NOP   7A
// implied addressing.
func opcode7A(cpu *CPU) {
	cpu.tick()
}

// RRA   7B
// absolute indexed Y.
func opcode7B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   7C
// absolute indexed X.
func opcode7C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// ADC   7D
// absolute indexed X.
func opcode7D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   7E
// absolute indexed X.
func opcode7E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   7F
// absolute indexed X.
func opcode7F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   80
// immediate addressing.
func opcode80(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// STA   81
// indexed addressing (abs, X).
func opcode81(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// NOP   82
// immediate addressing.
func opcode82(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// SAX   83
// indexed addressing (abs, X).
func opcode83(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// STY   84
// zero page addressing.
func opcode84(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

// STA   85
// zero page addressing.
func opcode85(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// STX   86
// zero page addressing.
func opcode86(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.X)
}

// SAX   87
// zero page addressing.
func opcode87(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// DEY   88
// implied addressing.
func opcode88(cpu *CPU) {
	cpu.tick()
	cpu.Y--
	cpu.P.checkNZ(cpu.Y)
}

// NOP   89
// immediate addressing.
func opcode89(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// TXA   8A
// implied addressing.
func opcode8A(cpu *CPU) {
	cpu.A = cpu.X
	cpu.P.checkNZ(cpu.X)
	cpu.tick()
}

// ANE   8B
// immediate addressing.
func opcode8B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x8B (ANE)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// STY   8C
// absolute addressing.
func opcode8C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

// STA   8D
// absolute addressing.
func opcode8D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// STX   8E
// absolute addressing.
func opcode8E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.X)
}

// SAX   8F
// absolute addressing.
func opcode8F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// BCC   90
// relative addressing.
func opcode90(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(0) == false {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// STA   91
// indexed addressing (abs),Y.
func opcode91(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// JAM   92
// immediate addressing.
func opcode92(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SHA   93
// indexed addressing (abs),Y.
func opcode93(cpu *CPU) {
	// default
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x93 (SHA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// STY   94
// indexed addressing: zeropage,X.
func opcode94(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

// STA   95
// indexed addressing: zeropage,X.
func opcode95(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// STX   96
// indexed addressing: zeropage,Y.
func opcode96(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.X)
}

// SAX   97
// indexed addressing: zeropage,Y.
func opcode97(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// TYA   98
// implied addressing.
func opcode98(cpu *CPU) {
	cpu.A = cpu.Y
	cpu.P.checkNZ(cpu.Y)
	cpu.tick()
}

// STA   99
// absolute indexed Y.
func opcode99(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// TXS   9A
// implied addressing.
func opcode9A(cpu *CPU) {
	cpu.SP = cpu.X
	cpu.tick()
}

// TAS   9B
// absolute indexed Y.
func opcode9B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9B (TAS)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SHY   9C
// absolute indexed X.
func opcode9C(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9C (SHY)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// STA   9D
// absolute indexed X.
func opcode9D(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// SHX   9E
// absolute indexed Y.
func opcode9E(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9E (SHX)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SHA   9F
// absolute indexed Y.
func opcode9F(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9F (SHA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// LDY   A0
// immediate addressing.
func opcodeA0(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

// LDA   A1
// indexed addressing (abs, X).
func opcodeA1(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// LDX   A2
// immediate addressing.
func opcodeA2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LAX   A3
// indexed addressing (abs, X).
func opcodeA3(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LDY   A4
// zero page addressing.
func opcodeA4(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

// LDA   A5
// zero page addressing.
func opcodeA5(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// LDX   A6
// zero page addressing.
func opcodeA6(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LAX   A7
// zero page addressing.
func opcodeA7(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

// TAY   A8
// implied addressing.
func opcodeA8(cpu *CPU) {
	cpu.Y = cpu.A
	cpu.P.checkNZ(cpu.A)
	cpu.tick()
}

// LDA   A9
// immediate addressing.
func opcodeA9(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// TAX   AA
// implied addressing.
func opcodeAA(cpu *CPU) {
	cpu.X = cpu.A
	cpu.P.checkNZ(cpu.A)
	cpu.tick()
}

// LXA   AB
// immediate addressing.
func opcodeAB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0xAB (LXA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// LDY   AC
// absolute addressing.
func opcodeAC(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

// LDA   AD
// absolute addressing.
func opcodeAD(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// LDX   AE
// absolute addressing.
func opcodeAE(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LAX   AF
// absolute addressing.
func opcodeAF(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

// BCS   B0
// relative addressing.
func opcodeB0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(0) == true {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// LDA   B1
// indexed addressing (abs),Y.
func opcodeB1(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// JAM   B2
// immediate addressing.
func opcodeB2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// LAX   B3
// indexed addressing (abs),Y.
func opcodeB3(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LDY   B4
// indexed addressing: zeropage,X.
func opcodeB4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

// LDA   B5
// indexed addressing: zeropage,X.
func opcodeB5(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// LDX   B6
// indexed addressing: zeropage,Y.
func opcodeB6(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LAX   B7
// indexed addressing: zeropage,Y.
func opcodeB7(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

// CLV   B8
// implied addressing.
func opcodeB8(cpu *CPU) {
	cpu.P.clearBit(6)
	cpu.tick()
}

// LDA   B9
// absolute indexed Y.
func opcodeB9(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// TSX   BA
// implied addressing.
func opcodeBA(cpu *CPU) {
	cpu.X = cpu.SP
	cpu.P.checkNZ(cpu.SP)
	cpu.tick()
}

// LAS   BB
// absolute indexed Y.
func opcodeBB(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = cpu.SP & val
	cpu.P.checkNZ(cpu.A)
	cpu.X = cpu.A
	cpu.SP = cpu.A
}

// LDY   BC
// absolute indexed X.
func opcodeBC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

// LDA   BD
// absolute indexed X.
func opcodeBD(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

// LDX   BE
// absolute indexed Y.
func opcodeBE(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

// LAX   BF
// absolute indexed Y.
func opcodeBF(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

// CPY   C0
// immediate addressing.
func opcodeC0(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.Y - val)
	cpu.P.writeBit(pbitC, val <= cpu.Y)
}

// CMP   C1
// indexed addressing (abs, X).
func opcodeC1(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// NOP   C2
// immediate addressing.
func opcodeC2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// DCP   C3
// indexed addressing (abs, X).
func opcodeC3(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// CPY   C4
// zero page addressing.
func opcodeC4(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.Y - val)
	cpu.P.writeBit(pbitC, val <= cpu.Y)
}

// CMP   C5
// zero page addressing.
func opcodeC5(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// DEC   C6
// zero page addressing.
func opcodeC6(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// DCP   C7
// zero page addressing.
func opcodeC7(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// INY   C8
// implied addressing.
func opcodeC8(cpu *CPU) {
	cpu.tick()
	cpu.Y++
	cpu.P.checkNZ(cpu.Y)
}

// CMP   C9
// immediate addressing.
func opcodeC9(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// DEX   CA
// implied addressing.
func opcodeCA(cpu *CPU) {
	cpu.tick()
	cpu.X--
	cpu.P.checkNZ(cpu.X)
}

// SBX   CB
// immediate addressing.
func opcodeCB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	ival := (int16(cpu.A) & int16(cpu.X)) - int16(val)
	cpu.X = uint8(ival)
	cpu.P.checkNZ(uint8(ival))
	cpu.P.writeBit(pbitC, ival >= 0)
}

// CPY   CC
// absolute addressing.
func opcodeCC(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.Y - val)
	cpu.P.writeBit(pbitC, val <= cpu.Y)
}

// CMP   CD
// absolute addressing.
func opcodeCD(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// DEC   CE
// absolute addressing.
func opcodeCE(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// DCP   CF
// absolute addressing.
func opcodeCF(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// BNE   D0
// relative addressing.
func opcodeD0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(1) == false {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// CMP   D1
// indexed addressing (abs),Y.
func opcodeD1(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// JAM   D2
// immediate addressing.
func opcodeD2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// DCP   D3
// indexed addressing (abs),Y.
func opcodeD3(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// NOP   D4
// indexed addressing: zeropage,X.
func opcodeD4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// CMP   D5
// indexed addressing: zeropage,X.
func opcodeD5(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// DEC   D6
// indexed addressing: zeropage,X.
func opcodeD6(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// DCP   D7
// indexed addressing: zeropage,X.
func opcodeD7(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// CLD   D8
// implied addressing.
func opcodeD8(cpu *CPU) {
	cpu.P.clearBit(3)
	cpu.tick()
}

// CMP   D9
// absolute indexed Y.
func opcodeD9(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// NOP   DA
// implied addressing.
func opcodeDA(cpu *CPU) {
	cpu.tick()
}

// DCP   DB
// absolute indexed Y.
func opcodeDB(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// NOP   DC
// absolute indexed X.
func opcodeDC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// CMP   DD
// absolute indexed X.
func opcodeDD(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
}

// DEC   DE
// absolute indexed X.
func opcodeDE(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// DCP   DF
// absolute indexed X.
func opcodeDF(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P.writeBit(pbitC, val <= cpu.A)
	cpu.Write8(oper, val)
}

// CPX   E0
// immediate addressing.
func opcodeE0(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.X - val)
	cpu.P.writeBit(pbitC, val <= cpu.X)
}

// SBC   E1
// indexed addressing (abs, X).
func opcodeE1(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// NOP   E2
// immediate addressing.
func opcodeE2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// ISB   E3
// indexed addressing (abs, X).
func opcodeE3(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// CPX   E4
// zero page addressing.
func opcodeE4(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.X - val)
	cpu.P.writeBit(pbitC, val <= cpu.X)
}

// SBC   E5
// zero page addressing.
func opcodeE5(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// INC   E6
// zero page addressing.
func opcodeE6(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// ISB   E7
// zero page addressing.
func opcodeE7(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// INX   E8
// implied addressing.
func opcodeE8(cpu *CPU) {
	cpu.tick()
	cpu.X++
	cpu.P.checkNZ(cpu.X)
}

// SBC   E9
// immediate addressing.
func opcodeE9(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// NOP   EA
// implied addressing.
func opcodeEA(cpu *CPU) {
	cpu.tick()
}

// SBC   EB
// immediate addressing.
func opcodeEB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// CPX   EC
// absolute addressing.
func opcodeEC(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.X - val)
	cpu.P.writeBit(pbitC, val <= cpu.X)
}

// SBC   ED
// absolute addressing.
func opcodeED(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// INC   EE
// absolute addressing.
func opcodeEE(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// ISB   EF
// absolute addressing.
func opcodeEF(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// BEQ   F0
// relative addressing.
func opcodeF0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(1) == true {
		// branching
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// SBC   F1
// indexed addressing (abs),Y.
func opcodeF1(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// JAM   F2
// immediate addressing.
func opcodeF2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// ISB   F3
// indexed addressing (abs),Y.
func opcodeF3(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// NOP   F4
// indexed addressing: zeropage,X.
func opcodeF4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// SBC   F5
// indexed addressing: zeropage,X.
func opcodeF5(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// INC   F6
// indexed addressing: zeropage,X.
func opcodeF6(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// ISB   F7
// indexed addressing: zeropage,X.
func opcodeF7(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// SED   F8
// implied addressing.
func opcodeF8(cpu *CPU) {
	cpu.P.setBit(3)
	cpu.tick()
}

// SBC   F9
// absolute indexed Y.
func opcodeF9(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// NOP   FA
// implied addressing.
func opcodeFA(cpu *CPU) {
	cpu.tick()
}

// ISB   FB
// absolute indexed Y.
func opcodeFB(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// NOP   FC
// absolute indexed X.
func opcodeFC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// SBC   FD
// absolute indexed X.
func opcodeFD(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// INC   FE
// absolute indexed X.
func opcodeFE(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

// ISB   FF
// absolute indexed X.
func opcodeFF(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

// unstable opcodes (unsupported)
var unstableOps = [256]uint8{
	0x02: 1, // JAM
	0x12: 1, // JAM
	0x22: 1, // JAM
	0x32: 1, // JAM
	0x42: 1, // JAM
	0x52: 1, // JAM
	0x62: 1, // JAM
	0x72: 1, // JAM
	0x8B: 1, // ANE
	0x92: 1, // JAM
	0x93: 1, // SHA
	0x9B: 1, // TAS
	0x9C: 1, // SHY
	0x9E: 1, // SHX
	0x9F: 1, // SHA
	0xAB: 1, // LXA
	0xB2: 1, // JAM
	0xD2: 1, // JAM
	0xF2: 1, // JAM
}

func copybits(dst, src, mask uint8) uint8 {
	return (dst & ^mask) | (src & mask)
}
