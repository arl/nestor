// Code generated by cpugen/gen_nes6502.go. DO NOT EDIT.
package emu

import (
	"fmt"
)

// BRK   00
// implied addressing.
func opcode_00(cpu *CPU) {
	cpu.tick()
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) >> 8)))
		cpu.SP -= 1
	}
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) & 0xFF)))
		cpu.SP -= 1
	}
	p := cpu.P
	p.setBit(pbitB)
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8(p)))
		cpu.SP -= 1
	}
	cpu.P.setBit(pbitI)
	cpu.PC = cpu.Read16(IRQvector)
}

// ORA   01
// indexed addressing (abs, X).
func opcode_01(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   02
// immediate addressing.
func opcode_02(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SLO   03
// indexed addressing (abs, X).
func opcode_03(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   04
// zero page addressing.
func opcode_04(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

// ORA   05
// zero page addressing.
func opcode_05(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   06
// zero page addressing.
func opcode_06(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   07
// zero page addressing.
func opcode_07(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PHP   08
// implied addressing.
func opcode_08(cpu *CPU) {
	cpu.tick()
	p := cpu.P
	p |= (1 << pbitB) | (1 << pbitU)
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8(p)))
		cpu.SP -= 1
	}
}

// ORA   09
// immediate addressing.
func opcode_09(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   0A
// adressing accumulator.
func opcode_0A(cpu *CPU) {
	val := cpu.A
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A = val
}

// ANC   0B
// immediate addressing.
func opcode_0B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, cpu.P.N())
}

// NOP   0C
// absolute addressing.
func opcode_0C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.tick()
}

// ORA   0D
// absolute addressing.
func opcode_0D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   0E
// absolute addressing.
func opcode_0E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   0F
// absolute addressing.
func opcode_0F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BPL   10
// relative addressing.
func opcode_10(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(7) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// ORA   11
// indexed addressing (abs),Y.
func opcode_11(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if pagecrossed(oper, oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   12
// immediate addressing.
func opcode_12(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SLO   13
// indexed addressing (abs),Y.
func opcode_13(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   14
// indexed addressing: zeropage,X.
func opcode_14(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// ORA   15
// indexed addressing: zeropage,X.
func opcode_15(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   16
// indexed addressing: zeropage,X.
func opcode_16(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   17
// indexed addressing: zeropage,X.
func opcode_17(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// CLC   18
// implied addressing.
func opcode_18(cpu *CPU) {
	cpu.P.clearBit(0)
	cpu.tick()
}

// ORA   19
// absolute indexed Y.
func opcode_19(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// NOP   1A
// implied addressing.
func opcode_1A(cpu *CPU) {
	cpu.tick()
}

// SLO   1B
// absolute indexed Y.
func opcode_1B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   1C
// absolute indexed X.
func opcode_1C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// ORA   1D
// absolute indexed X.
func opcode_1D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ASL   1E
// absolute indexed X.
func opcode_1E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// SLO   1F
// absolute indexed X.
func opcode_1F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80 // carry is bit 7
	val <<= 1
	val &= 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// JSR   20
func opcode_20(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.tick()
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) >> 8)))
		cpu.SP -= 1
	}
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (uint8((cpu.PC + 1) & 0xFF)))
		cpu.SP -= 1
	}
	cpu.PC = oper
}

// AND   21
// indexed addressing (abs, X).
func opcode_21(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   22
// immediate addressing.
func opcode_22(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RLA   23
// indexed addressing (abs, X).
func opcode_23(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BIT   24
// zero page addressing.
func opcode_24(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P &= 0b00111111
	cpu.P |= P(val & 0b11000000)
	cpu.P.checkZ(cpu.A & val)
}

// AND   25
// zero page addressing.
func opcode_25(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   26
// zero page addressing.
func opcode_26(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   27
// zero page addressing.
func opcode_27(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PLP   28
// implied addressing.
func opcode_28(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var p uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		p = cpu.Read8(top)
	}
	const mask = 0b11001111 // ignore B and U bits
	cpu.P = P(copybits(uint8(cpu.P), p, mask))
}

// AND   29
// immediate addressing.
func opcode_29(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   2A
// adressing accumulator.
func opcode_2A(cpu *CPU) {
	val := cpu.A
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A = val
}

// ANC   2B
// immediate addressing.
func opcode_2B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, cpu.P.N())
}

// BIT   2C
// absolute addressing.
func opcode_2C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P &= 0b00111111
	cpu.P |= P(val & 0b11000000)
	cpu.P.checkZ(cpu.A & val)
}

// AND   2D
// absolute addressing.
func opcode_2D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   2E
// absolute addressing.
func opcode_2E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   2F
// absolute addressing.
func opcode_2F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BMI   30
// relative addressing.
func opcode_30(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(7) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// AND   31
// indexed addressing (abs),Y.
func opcode_31(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if pagecrossed(oper, oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   32
// immediate addressing.
func opcode_32(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RLA   33
// indexed addressing (abs),Y.
func opcode_33(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   34
// indexed addressing: zeropage,X.
func opcode_34(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// AND   35
// indexed addressing: zeropage,X.
func opcode_35(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   36
// indexed addressing: zeropage,X.
func opcode_36(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   37
// indexed addressing: zeropage,X.
func opcode_37(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// SEC   38
// implied addressing.
func opcode_38(cpu *CPU) {
	cpu.P.setBit(0)
	cpu.tick()
}

// AND   39
// absolute indexed Y.
func opcode_39(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// NOP   3A
// implied addressing.
func opcode_3A(cpu *CPU) {
	cpu.tick()
}

// RLA   3B
// absolute indexed Y.
func opcode_3B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   3C
// absolute indexed X.
func opcode_3C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// AND   3D
// absolute indexed X.
func opcode_3D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

// ROL   3E
// absolute indexed X.
func opcode_3E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.Write8(oper, val)
}

// RLA   3F
// absolute indexed X.
func opcode_3F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.C() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P.writeBit(pbitC, carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// RTI   40
// implied addressing.
func opcode_40(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var p uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		p = cpu.Read8(top)
	}
	const mask = 0b11001111 // ignore B and U bits
	cpu.P = P(copybits(uint8(cpu.P), p, mask))
	cpu.PC = pull16(cpu)
}

// EOR   41
// indexed addressing (abs, X).
func opcode_41(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   42
// immediate addressing.
func opcode_42(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SRE   43
// indexed addressing (abs, X).
func opcode_43(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   44
// zero page addressing.
func opcode_44(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

// EOR   45
// zero page addressing.
func opcode_45(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   46
// zero page addressing.
func opcode_46(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   47
// zero page addressing.
func opcode_47(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PHA   48
// implied addressing.
func opcode_48(cpu *CPU) {
	cpu.tick()
	{
		top := uint16(cpu.SP) + 0x0100
		cpu.Write8(top, (cpu.A))
		cpu.SP -= 1
	}
}

// EOR   49
// immediate addressing.
func opcode_49(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   4A
// adressing accumulator.
func opcode_4A(cpu *CPU) {
	val := cpu.A
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A = val
}

// ALR   4B
// immediate addressing.
func opcode_4B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	// like and + lsr but saves one tick
	cpu.A &= val
	carry := cpu.A & 0x01 // carry is bit 0
	cpu.A >>= 1
	cpu.A &= 0x7f
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, carry != 0)
}

// JMP   4C
// absolute addressing.
func opcode_4C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.PC = oper
}

// EOR   4D
// absolute addressing.
func opcode_4D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   4E
// absolute addressing.
func opcode_4E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   4F
// absolute addressing.
func opcode_4F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BVC   50
// relative addressing.
func opcode_50(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(6) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// EOR   51
// indexed addressing (abs),Y.
func opcode_51(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if pagecrossed(oper, oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   52
// immediate addressing.
func opcode_52(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SRE   53
// indexed addressing (abs),Y.
func opcode_53(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   54
// indexed addressing: zeropage,X.
func opcode_54(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// EOR   55
// indexed addressing: zeropage,X.
func opcode_55(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   56
// indexed addressing: zeropage,X.
func opcode_56(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   57
// indexed addressing: zeropage,X.
func opcode_57(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// CLI   58
// implied addressing.
func opcode_58(cpu *CPU) {
	cpu.P.clearBit(2)
	cpu.tick()
}

// EOR   59
// absolute indexed Y.
func opcode_59(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// NOP   5A
// implied addressing.
func opcode_5A(cpu *CPU) {
	cpu.tick()
}

// SRE   5B
// absolute indexed Y.
func opcode_5B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   5C
// absolute indexed X.
func opcode_5C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// EOR   5D
// absolute indexed X.
func opcode_5D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

// LSR   5E
// absolute indexed X.
func opcode_5E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// SRE   5F
// absolute indexed X.
func opcode_5F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val >>= 1
		val &= 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// RTS   60
// implied addressing.
func opcode_60(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var lo, hi uint8
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		lo = cpu.Read8(top)
	}
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		hi = cpu.Read8(top)
	}
	cpu.PC = uint16(hi)<<8 | uint16(lo)
	cpu.PC++
	cpu.tick()
}

// ADC   61
// indexed addressing (abs, X).
func opcode_61(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// JAM   62
// immediate addressing.
func opcode_62(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RRA   63
// indexed addressing (abs, X).
func opcode_63(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   64
// zero page addressing.
func opcode_64(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

// ADC   65
// zero page addressing.
func opcode_65(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   66
// zero page addressing.
func opcode_66(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   67
// zero page addressing.
func opcode_67(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// PLA   68
// implied addressing.
func opcode_68(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	{
		cpu.SP += 1
		top := uint16(cpu.SP) + 0x0100
		cpu.A = cpu.Read8(top)
	}
	cpu.P.checkNZ(cpu.A)
}

// ADC   69
// immediate addressing.
func opcode_69(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   6A
// adressing accumulator.
func opcode_6A(cpu *CPU) {
	val := cpu.A
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.A = val
}

// ARR   6B
// immediate addressing.
func opcode_6B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.A >>= 1
	cpu.P.writeBit(pbitV, (cpu.A>>6)^(cpu.A>>5)&0x01 != 0)
	// bit 7 is set to prev carry
	if cpu.P.C() {
		cpu.A |= 1 << 7
	}
	cpu.P.checkNZ(cpu.A)
	cpu.P.writeBit(pbitC, cpu.A&(1<<6) != 0)
}

// JMP   6C
// indirect addressing.
func opcode_6C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	lo := cpu.Read8(oper)
	// 2 bytes address wrap around
	hi := cpu.Read8((0xff00 & oper) | (0x00ff & (oper + 1)))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.PC = oper
}

// ADC   6D
// absolute addressing.
func opcode_6D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   6E
// absolute addressing.
func opcode_6E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   6F
// absolute addressing.
func opcode_6F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// BVS   70
// relative addressing.
func opcode_70(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(6) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// ADC   71
// indexed addressing (abs),Y.
func opcode_71(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if pagecrossed(oper, oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// JAM   72
// immediate addressing.
func opcode_72(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// RRA   73
// indexed addressing (abs),Y.
func opcode_73(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   74
// indexed addressing: zeropage,X.
func opcode_74(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// ADC   75
// indexed addressing: zeropage,X.
func opcode_75(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   76
// indexed addressing: zeropage,X.
func opcode_76(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   77
// indexed addressing: zeropage,X.
func opcode_77(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// SEI   78
// implied addressing.
func opcode_78(cpu *CPU) {
	cpu.P.setBit(2)
	cpu.tick()
}

// ADC   79
// absolute indexed Y.
func opcode_79(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// NOP   7A
// implied addressing.
func opcode_7A(cpu *CPU) {
	cpu.tick()
}

// RRA   7B
// absolute indexed Y.
func opcode_7B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   7C
// absolute indexed X.
func opcode_7C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// ADC   7D
// absolute indexed X.
func opcode_7D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

// ROR   7E
// absolute indexed X.
func opcode_7E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	cpu.Write8(oper, val)
}

// RRA   7F
// absolute indexed X.
func opcode_7F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // next carry is bit 0
		val >>= 1
		// bit 7 is set to prev carry
		if cpu.P.C() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P.writeBit(pbitC, carry != 0)
	}
	carry := cpu.P.ibit(pbitC)
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

// NOP   80
// immediate addressing.
func opcode_80(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// STA   81
// indexed addressing (abs, X).
func opcode_81(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// NOP   82
// immediate addressing.
func opcode_82(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// SAX   83
// indexed addressing (abs, X).
func opcode_83(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// STY   84
// zero page addressing.
func opcode_84(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

// STA   85
// zero page addressing.
func opcode_85(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// STX   86
// zero page addressing.
func opcode_86(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.X)
}

// SAX   87
// zero page addressing.
func opcode_87(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// DEY   88
// implied addressing.
func opcode_88(cpu *CPU) {
	cpu.tick()
	cpu.Y--
	cpu.P.checkNZ(cpu.Y)
}

// NOP   89
// immediate addressing.
func opcode_89(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// TXA   8A
// implied addressing.
func opcode_8A(cpu *CPU) {
	cpu.A = cpu.X
	cpu.P.checkNZ(cpu.A)
	cpu.tick()
}

// ANE   8B
// immediate addressing.
func opcode_8B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x8B (ANE)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// STY   8C
// absolute addressing.
func opcode_8C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

// STA   8D
// absolute addressing.
func opcode_8D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// STX   8E
// absolute addressing.
func opcode_8E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.X)
}

// SAX   8F
// absolute addressing.
func opcode_8F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// BCC   90
// relative addressing.
func opcode_90(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(0) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// STA   91
// indexed addressing (abs),Y.
func opcode_91(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// JAM   92
// immediate addressing.
func opcode_92(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SHA   93
// indexed addressing (abs),Y.
func opcode_93(cpu *CPU) {
	// default
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x93 (SHA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// STY   94
// indexed addressing: zeropage,X.
func opcode_94(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

// STA   95
// indexed addressing: zeropage,X.
func opcode_95(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// STX   96
// indexed addressing: zeropage,Y.
func opcode_96(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.X)
}

// SAX   97
// indexed addressing: zeropage,Y.
func opcode_97(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

// TYA   98
// implied addressing.
func opcode_98(cpu *CPU) {
	cpu.A = cpu.Y
	cpu.P.checkNZ(cpu.A)
	cpu.tick()
}

// STA   99
// absolute indexed Y.
func opcode_99(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// TXS   9A
// implied addressing.
func opcode_9A(cpu *CPU) {
	cpu.SP = cpu.X
	cpu.tick()
}

// TAS   9B
// absolute indexed Y.
func opcode_9B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9B (TAS)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SHY   9C
// absolute indexed X.
func opcode_9C(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9C (SHY)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// STA   9D
// absolute indexed X.
func opcode_9D(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

// SHX   9E
// absolute indexed Y.
func opcode_9E(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9E (SHX)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// SHA   9F
// absolute indexed Y.
func opcode_9F(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9F (SHA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// LXA   AB
// immediate addressing.
func opcode_AB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0xAB (LXA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// BCS   B0
// relative addressing.
func opcode_B0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(0) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   B2
// immediate addressing.
func opcode_B2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// CLV   B8
// implied addressing.
func opcode_B8(cpu *CPU) {
	cpu.P.clearBit(6)
	cpu.tick()
}

// NOP   C2
// immediate addressing.
func opcode_C2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// DEX   CA
// implied addressing.
func opcode_CA(cpu *CPU) {
	cpu.tick()
	cpu.X--
	cpu.P.checkNZ(cpu.X)
}

// BNE   D0
// relative addressing.
func opcode_D0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(1) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   D2
// immediate addressing.
func opcode_D2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// NOP   D4
// indexed addressing: zeropage,X.
func opcode_D4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// CLD   D8
// implied addressing.
func opcode_D8(cpu *CPU) {
	cpu.P.clearBit(3)
	cpu.tick()
}

// NOP   DA
// implied addressing.
func opcode_DA(cpu *CPU) {
	cpu.tick()
}

// NOP   DC
// absolute indexed X.
func opcode_DC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

// NOP   E2
// immediate addressing.
func opcode_E2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

// NOP   EA
// implied addressing.
func opcode_EA(cpu *CPU) {
	cpu.tick()
}

// BEQ   F0
// relative addressing.
func opcode_F0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(1) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   F2
// immediate addressing.
func opcode_F2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

// NOP   F4
// indexed addressing: zeropage,X.
func opcode_F4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

// SED   F8
// implied addressing.
func opcode_F8(cpu *CPU) {
	cpu.P.setBit(3)
	cpu.tick()
}

// NOP   FA
// implied addressing.
func opcode_FA(cpu *CPU) {
	cpu.tick()
}

// NOP   FC
// absolute indexed X.
func opcode_FC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

var gdefs = [256]func(*CPU){
	0x00: opcode_00,
	0x01: opcode_01,
	0x02: opcode_02,
	0x03: opcode_03,
	0x04: opcode_04,
	0x05: opcode_05,
	0x06: opcode_06,
	0x07: opcode_07,
	0x08: opcode_08,
	0x09: opcode_09,
	0x0A: opcode_0A,
	0x0B: opcode_0B,
	0x0C: opcode_0C,
	0x0D: opcode_0D,
	0x0E: opcode_0E,
	0x0F: opcode_0F,
	0x10: opcode_10,
	0x11: opcode_11,
	0x12: opcode_12,
	0x13: opcode_13,
	0x14: opcode_14,
	0x15: opcode_15,
	0x16: opcode_16,
	0x17: opcode_17,
	0x18: opcode_18,
	0x19: opcode_19,
	0x1A: opcode_1A,
	0x1B: opcode_1B,
	0x1C: opcode_1C,
	0x1D: opcode_1D,
	0x1E: opcode_1E,
	0x1F: opcode_1F,
	0x20: opcode_20,
	0x21: opcode_21,
	0x22: opcode_22,
	0x23: opcode_23,
	0x24: opcode_24,
	0x25: opcode_25,
	0x26: opcode_26,
	0x27: opcode_27,
	0x28: opcode_28,
	0x29: opcode_29,
	0x2A: opcode_2A,
	0x2B: opcode_2B,
	0x2C: opcode_2C,
	0x2D: opcode_2D,
	0x2E: opcode_2E,
	0x2F: opcode_2F,
	0x30: opcode_30,
	0x31: opcode_31,
	0x32: opcode_32,
	0x33: opcode_33,
	0x34: opcode_34,
	0x35: opcode_35,
	0x36: opcode_36,
	0x37: opcode_37,
	0x38: opcode_38,
	0x39: opcode_39,
	0x3A: opcode_3A,
	0x3B: opcode_3B,
	0x3C: opcode_3C,
	0x3D: opcode_3D,
	0x3E: opcode_3E,
	0x3F: opcode_3F,
	0x40: opcode_40,
	0x41: opcode_41,
	0x42: opcode_42,
	0x43: opcode_43,
	0x44: opcode_44,
	0x45: opcode_45,
	0x46: opcode_46,
	0x47: opcode_47,
	0x48: opcode_48,
	0x49: opcode_49,
	0x4A: opcode_4A,
	0x4B: opcode_4B,
	0x4C: opcode_4C,
	0x4D: opcode_4D,
	0x4E: opcode_4E,
	0x4F: opcode_4F,
	0x50: opcode_50,
	0x51: opcode_51,
	0x52: opcode_52,
	0x53: opcode_53,
	0x54: opcode_54,
	0x55: opcode_55,
	0x56: opcode_56,
	0x57: opcode_57,
	0x58: opcode_58,
	0x59: opcode_59,
	0x5A: opcode_5A,
	0x5B: opcode_5B,
	0x5C: opcode_5C,
	0x5D: opcode_5D,
	0x5E: opcode_5E,
	0x5F: opcode_5F,
	0x60: opcode_60,
	0x61: opcode_61,
	0x62: opcode_62,
	0x63: opcode_63,
	0x64: opcode_64,
	0x65: opcode_65,
	0x66: opcode_66,
	0x67: opcode_67,
	0x68: opcode_68,
	0x69: opcode_69,
	0x6A: opcode_6A,
	0x6B: opcode_6B,
	0x6C: opcode_6C,
	0x6D: opcode_6D,
	0x6E: opcode_6E,
	0x6F: opcode_6F,
	0x70: opcode_70,
	0x71: opcode_71,
	0x72: opcode_72,
	0x73: opcode_73,
	0x74: opcode_74,
	0x75: opcode_75,
	0x76: opcode_76,
	0x77: opcode_77,
	0x78: opcode_78,
	0x79: opcode_79,
	0x7A: opcode_7A,
	0x7B: opcode_7B,
	0x7C: opcode_7C,
	0x7D: opcode_7D,
	0x7E: opcode_7E,
	0x7F: opcode_7F,
	0x80: opcode_80,
	0x81: opcode_81,
	0x82: opcode_82,
	0x83: opcode_83,
	0x84: opcode_84,
	0x85: opcode_85,
	0x86: opcode_86,
	0x87: opcode_87,
	0x88: opcode_88,
	0x89: opcode_89,
	0x8A: opcode_8A,
	0x8B: opcode_8B,
	0x8C: opcode_8C,
	0x8D: opcode_8D,
	0x8E: opcode_8E,
	0x8F: opcode_8F,
	0x90: opcode_90,
	0x91: opcode_91,
	0x92: opcode_92,
	0x93: opcode_93,
	0x94: opcode_94,
	0x95: opcode_95,
	0x96: opcode_96,
	0x97: opcode_97,
	0x98: opcode_98,
	0x99: opcode_99,
	0x9A: opcode_9A,
	0x9B: opcode_9B,
	0x9C: opcode_9C,
	0x9D: opcode_9D,
	0x9E: opcode_9E,
	0x9F: opcode_9F,
	0xAB: opcode_AB,
	0xB0: opcode_B0,
	0xB2: opcode_B2,
	0xB8: opcode_B8,
	0xC2: opcode_C2,
	0xCA: opcode_CA,
	0xD0: opcode_D0,
	0xD2: opcode_D2,
	0xD4: opcode_D4,
	0xD8: opcode_D8,
	0xDA: opcode_DA,
	0xDC: opcode_DC,
	0xE2: opcode_E2,
	0xEA: opcode_EA,
	0xF0: opcode_F0,
	0xF2: opcode_F2,
	0xF4: opcode_F4,
	0xF8: opcode_F8,
	0xFA: opcode_FA,
	0xFC: opcode_FC,
}

// unstable opcodes (unsupported)
var unstableOps = [256]uint8{
	0x02: 1, // JAM
	0x12: 1, // JAM
	0x22: 1, // JAM
	0x32: 1, // JAM
	0x42: 1, // JAM
	0x52: 1, // JAM
	0x62: 1, // JAM
	0x72: 1, // JAM
	0x8B: 1, // ANE
	0x92: 1, // JAM
	0x93: 1, // SHA
	0x9B: 1, // TAS
	0x9C: 1, // SHY
	0x9E: 1, // SHX
	0x9F: 1, // SHA
	0xAB: 1, // LXA
	0xB2: 1, // JAM
	0xD2: 1, // JAM
	0xF2: 1, // JAM
}
