// Code generated by cpugen/gen_nes6502.go. DO NOT EDIT.
package emu

// BRK   00
// implied addressing.
func opcode_00(cpu *CPU) {
	cpu.tick()
	push16(cpu, cpu.PC+1)
	p := cpu.P
	p.setBit(pbitB)
	push8(cpu, uint8(p))
	cpu.P.setBit(pbitI)
	cpu.PC = cpu.Read16(IRQvector)
}

// ORA   01
// indexed addressing (abs, X).
func opcode_01(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   02
// immediate addressing.
func opcode_02(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// ORA   05
// zero page addressing.
func opcode_05(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ORA   09
// immediate addressing.
func opcode_09(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ORA   0D
// absolute addressing.
func opcode_0D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// BPL   10
// relative addressing.
func opcode_10(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(7) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// ORA   11
// indexed addressing (abs),Y.
func opcode_11(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if pagecrossed(oper, oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   12
// immediate addressing.
func opcode_12(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// ORA   15
// indexed addressing: zeropage,X.
func opcode_15(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ORA   19
// absolute indexed Y.
func opcode_19(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// ORA   1D
// absolute indexed X.
func opcode_1D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if pagecrossed(oper, addr) {
		cpu.tick()
	}
	_ = oper
	// ORA
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

// JAM   22
// immediate addressing.
func opcode_22(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BMI   30
// relative addressing.
func opcode_30(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(7) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   32
// immediate addressing.
func opcode_32(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// JAM   42
// immediate addressing.
func opcode_42(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BVC   50
// relative addressing.
func opcode_50(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(6) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   52
// immediate addressing.
func opcode_52(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// JAM   62
// immediate addressing.
func opcode_62(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BVS   70
// relative addressing.
func opcode_70(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(6) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   72
// immediate addressing.
func opcode_72(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BCC   90
// relative addressing.
func opcode_90(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(0) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   92
// immediate addressing.
func opcode_92(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BCS   B0
// relative addressing.
func opcode_B0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(0) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   B2
// immediate addressing.
func opcode_B2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BNE   D0
// relative addressing.
func opcode_D0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(1) == false {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   D2
// immediate addressing.
func opcode_D2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

// BEQ   F0
// relative addressing.
func opcode_F0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.bit(1) == true {
		// branching
		if pagecrossed(cpu.PC+1, oper) {
			cpu.tick()
		}
		cpu.tick()
		cpu.PC = oper
		return
	}
	cpu.PC++
}

// JAM   F2
// immediate addressing.
func opcode_F2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	panic("Halt and catch fire!")
}

var gdefs = [256]func(*CPU){
	0x00: opcode_00,
	0x01: opcode_01,
	0x02: opcode_02,
	0x05: opcode_05,
	0x09: opcode_09,
	0x0D: opcode_0D,
	0x10: opcode_10,
	0x11: opcode_11,
	0x12: opcode_12,
	0x15: opcode_15,
	0x19: opcode_19,
	0x1D: opcode_1D,
	0x22: opcode_22,
	0x30: opcode_30,
	0x32: opcode_32,
	0x42: opcode_42,
	0x50: opcode_50,
	0x52: opcode_52,
	0x62: opcode_62,
	0x70: opcode_70,
	0x72: opcode_72,
	0x90: opcode_90,
	0x92: opcode_92,
	0xB0: opcode_B0,
	0xB2: opcode_B2,
	0xD0: opcode_D0,
	0xD2: opcode_D2,
	0xF0: opcode_F0,
	0xF2: opcode_F2,
}
