// Code generated by cpugen/gen_nes6502.go. DO NOT EDIT.
package hw

import (
	"bytes"
	"fmt"
)

func disasmOpcode00(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " BRK")
}

// ORA - indexed addressing (abs, X).
func opcode01(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode01(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " ORA")
}

// JAM - immediate addressing.
func opcode02(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x02) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode02(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// SLO - indexed addressing (abs, X).
func opcode03(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode03(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*SLO")
}

// NOP - zero page addressing.
func opcode04(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcode04(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*NOP")
}

// ORA - zero page addressing.
func opcode05(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode05(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " ORA")
}

// ASL - zero page addressing.
func opcode06(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode06(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " ASL")
}

// SLO - zero page addressing.
func opcode07(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode07(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*SLO")
}

// PHP - implied addressing.
func opcode08(cpu *CPU) {
	cpu.tick()
	p := cpu.P.SetBreak(true).SetUnused(true)
	cpu.push8(uint8(p))
}

func disasmOpcode08(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " PHP")
}

// ORA - immediate addressing.
func opcode09(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode09(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " ORA")
}

// ASL - adressing accumulator.
func opcode0A(cpu *CPU) {
	val := cpu.A
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A = val
}

func disasmOpcode0A(cpu *CPU, pc uint16) []byte {
	return disasmAcc(cpu, pc, " ASL")
}

// ANC - immediate addressing.
func opcode0B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.P = cpu.P.SetCarry(cpu.P.Negative())
}

func disasmOpcode0B(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*ANC")
}

// NOP - absolute addressing.
func opcode0C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.tick()
}

func disasmOpcode0C(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*NOP")
}

// ORA - absolute addressing.
func opcode0D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode0D(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " ORA")
}

// ASL - absolute addressing.
func opcode0E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode0E(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " ASL")
}

// SLO - absolute addressing.
func opcode0F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode0F(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*SLO")
}

// BPL - relative addressing.
func opcode10(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if !cpu.P.Negative() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcode10(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BPL")
}

// ORA - indexed addressing (abs),Y.
func opcode11(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode11(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " ORA")
}

// JAM - immediate addressing.
func opcode12(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x12) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode12(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// SLO - indexed addressing (abs),Y.
func opcode13(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode13(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*SLO")
}

// NOP - indexed addressing: zeropage,X.
func opcode14(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

func disasmOpcode14(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*NOP")
}

// ORA - indexed addressing: zeropage,X.
func opcode15(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode15(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " ORA")
}

// ASL - indexed addressing: zeropage,X.
func opcode16(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode16(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " ASL")
}

// SLO - indexed addressing: zeropage,X.
func opcode17(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode17(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*SLO")
}

// CLC - implied addressing.
func opcode18(cpu *CPU) {
	cpu.P = cpu.P.SetCarry(false)
	cpu.tick()
}

func disasmOpcode18(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " CLC")
}

// ORA - absolute indexed Y.
func opcode19(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode19(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " ORA")
}

// NOP - implied addressing.
func opcode1A(cpu *CPU) {
	cpu.tick()
}

func disasmOpcode1A(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, "*NOP")
}

// SLO - absolute indexed Y.
func opcode1B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode1B(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*SLO")
}

// NOP - absolute indexed X.
func opcode1C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

func disasmOpcode1C(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*NOP")
}

// ORA - absolute indexed X.
func opcode1D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode1D(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " ORA")
}

// ASL - absolute indexed X.
func opcode1E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode1E(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " ASL")
}

// SLO - absolute indexed X.
func opcode1F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val = (val << 1) & 0xfe
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A |= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode1F(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*SLO")
}

// JSR - absolute addressing.
func opcode20(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.tick()
	cpu.push16(cpu.PC - 1)
	cpu.PC = oper
}

func disasmOpcode20(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " JSR")
}

// AND - indexed addressing (abs, X).
func opcode21(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode21(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " AND")
}

// JAM - immediate addressing.
func opcode22(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x22) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode22(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// RLA - indexed addressing (abs, X).
func opcode23(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode23(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*RLA")
}

// BIT - zero page addressing.
func opcode24(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P &= 0b00111111
	cpu.P |= P(val & 0b11000000)
	cpu.P.checkZ(cpu.A & val)
}

func disasmOpcode24(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " BIT")
}

// AND - zero page addressing.
func opcode25(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode25(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " AND")
}

// ROL - zero page addressing.
func opcode26(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode26(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " ROL")
}

// RLA - zero page addressing.
func opcode27(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode27(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*RLA")
}

// PLP - implied addressing.
func opcode28(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var p uint8
	p = cpu.pull8()
	const mask uint8 = 0b11001111 // ignore B and U bits
	cpu.P = P(((uint8(cpu.P)) & (^mask)) | ((p) & (mask)))
}

func disasmOpcode28(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " PLP")
}

// AND - immediate addressing.
func opcode29(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode29(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " AND")
}

// ROL - adressing accumulator.
func opcode2A(cpu *CPU) {
	val := cpu.A
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A = val
}

func disasmOpcode2A(cpu *CPU, pc uint16) []byte {
	return disasmAcc(cpu, pc, " ROL")
}

// ANC - immediate addressing.
func opcode2B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.P = cpu.P.SetCarry(cpu.P.Negative())
}

func disasmOpcode2B(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*ANC")
}

// BIT - absolute addressing.
func opcode2C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P &= 0b00111111
	cpu.P |= P(val & 0b11000000)
	cpu.P.checkZ(cpu.A & val)
}

func disasmOpcode2C(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " BIT")
}

// AND - absolute addressing.
func opcode2D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode2D(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " AND")
}

// ROL - absolute addressing.
func opcode2E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode2E(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " ROL")
}

// RLA - absolute addressing.
func opcode2F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode2F(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*RLA")
}

// BMI - relative addressing.
func opcode30(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.Negative() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcode30(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BMI")
}

// AND - indexed addressing (abs),Y.
func opcode31(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode31(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " AND")
}

// JAM - immediate addressing.
func opcode32(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x32) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode32(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// RLA - indexed addressing (abs),Y.
func opcode33(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode33(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*RLA")
}

// NOP - indexed addressing: zeropage,X.
func opcode34(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

func disasmOpcode34(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*NOP")
}

// AND - indexed addressing: zeropage,X.
func opcode35(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode35(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " AND")
}

// ROL - indexed addressing: zeropage,X.
func opcode36(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode36(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " ROL")
}

// RLA - indexed addressing: zeropage,X.
func opcode37(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode37(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*RLA")
}

// SEC - implied addressing.
func opcode38(cpu *CPU) {
	cpu.P = cpu.P.SetCarry(true)
	cpu.tick()
}

func disasmOpcode38(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " SEC")
}

// AND - absolute indexed Y.
func opcode39(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode39(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " AND")
}

// NOP - implied addressing.
func opcode3A(cpu *CPU) {
	cpu.tick()
}

func disasmOpcode3A(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, "*NOP")
}

// RLA - absolute indexed Y.
func opcode3B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode3B(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*RLA")
}

// NOP - absolute indexed X.
func opcode3C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

func disasmOpcode3C(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*NOP")
}

// AND - absolute indexed X.
func opcode3D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode3D(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " AND")
}

// ROL - absolute indexed X.
func opcode3E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.Write8(oper, val)
}

func disasmOpcode3E(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " ROL")
}

// RLA - absolute indexed X.
func opcode3F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	carry := val & 0x80
	val <<= 1
	if cpu.P.Carry() {
		val |= 1 << 0
	}
	cpu.tick()
	cpu.P.checkNZ(val)
	cpu.P = cpu.P.SetCarry(carry != 0)
	cpu.A &= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode3F(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*RLA")
}

// RTI - implied addressing.
func opcode40(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	var p uint8
	p = cpu.pull8()
	const mask uint8 = 0b11001111 // ignore B and U bits
	cpu.P = P(((uint8(cpu.P)) & (^mask)) | ((p) & (mask)))
	cpu.PC = cpu.pull16()
}

func disasmOpcode40(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " RTI")
}

// EOR - indexed addressing (abs, X).
func opcode41(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode41(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " EOR")
}

// JAM - immediate addressing.
func opcode42(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x42) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode42(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// SRE - indexed addressing (abs, X).
func opcode43(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode43(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*SRE")
}

// NOP - zero page addressing.
func opcode44(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcode44(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*NOP")
}

// EOR - zero page addressing.
func opcode45(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode45(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " EOR")
}

// LSR - zero page addressing.
func opcode46(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode46(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " LSR")
}

// SRE - zero page addressing.
func opcode47(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode47(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*SRE")
}

// PHA - implied addressing.
func opcode48(cpu *CPU) {
	cpu.tick()
	cpu.push8(cpu.A)
}

func disasmOpcode48(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " PHA")
}

// EOR - immediate addressing.
func opcode49(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode49(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " EOR")
}

// LSR - adressing accumulator.
func opcode4A(cpu *CPU) {
	val := cpu.A
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A = val
}

func disasmOpcode4A(cpu *CPU, pc uint16) []byte {
	return disasmAcc(cpu, pc, " LSR")
}

// ALR - immediate addressing.
func opcode4B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	// like and + lsr but saves one tick
	cpu.A &= val
	carry := cpu.A & 0x01 // carry is bit 0
	cpu.A = (cpu.A >> 1) & 0x7f
	cpu.P.checkNZ(cpu.A)
	cpu.P = cpu.P.SetCarry(carry != 0)
}

func disasmOpcode4B(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*ALR")
}

// JMP - absolute addressing.
func opcode4C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.PC = oper
}

func disasmOpcode4C(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " JMP")
}

// EOR - absolute addressing.
func opcode4D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode4D(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " EOR")
}

// LSR - absolute addressing.
func opcode4E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode4E(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " LSR")
}

// SRE - absolute addressing.
func opcode4F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode4F(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*SRE")
}

// BVC - relative addressing.
func opcode50(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if !cpu.P.Overflow() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcode50(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BVC")
}

// EOR - indexed addressing (abs),Y.
func opcode51(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode51(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " EOR")
}

// JAM - immediate addressing.
func opcode52(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x52) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode52(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// SRE - indexed addressing (abs),Y.
func opcode53(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode53(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*SRE")
}

// NOP - indexed addressing: zeropage,X.
func opcode54(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

func disasmOpcode54(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*NOP")
}

// EOR - indexed addressing: zeropage,X.
func opcode55(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode55(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " EOR")
}

// LSR - indexed addressing: zeropage,X.
func opcode56(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode56(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " LSR")
}

// SRE - indexed addressing: zeropage,X.
func opcode57(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode57(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*SRE")
}

// CLI - implied addressing.
func opcode58(cpu *CPU) {
	cpu.P = cpu.P.SetIntDisable(false)
	cpu.tick()
}

func disasmOpcode58(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " CLI")
}

// EOR - absolute indexed Y.
func opcode59(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode59(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " EOR")
}

// NOP - implied addressing.
func opcode5A(cpu *CPU) {
	cpu.tick()
}

func disasmOpcode5A(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, "*NOP")
}

// SRE - absolute indexed Y.
func opcode5B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode5B(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*SRE")
}

// NOP - absolute indexed X.
func opcode5C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

func disasmOpcode5C(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*NOP")
}

// EOR - absolute indexed X.
func opcode5D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode5D(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " EOR")
}

// LSR - absolute indexed X.
func opcode5E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode5E(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " LSR")
}

// SRE - absolute indexed X.
func opcode5F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01 // carry is bit 0
		val = (val >> 1) & 0x7f
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A ^= val
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode5F(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*SRE")
}

// RTS - implied addressing.
func opcode60(cpu *CPU) {
	cpu.PC = cpu.pull16()
	cpu.tick()
	cpu.tick()
	cpu.PC++
	cpu.tick()
}

func disasmOpcode60(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " RTS")
}

// ADC - indexed addressing (abs, X).
func opcode61(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode61(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " ADC")
}

// JAM - immediate addressing.
func opcode62(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x62) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode62(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// RRA - indexed addressing (abs, X).
func opcode63(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode63(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*RRA")
}

// NOP - zero page addressing.
func opcode64(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcode64(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*NOP")
}

// ADC - zero page addressing.
func opcode65(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode65(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " ADC")
}

// ROR - zero page addressing.
func opcode66(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode66(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " ROR")
}

// RRA - zero page addressing.
func opcode67(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode67(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*RRA")
}

// PLA - implied addressing.
func opcode68(cpu *CPU) {
	cpu.tick()
	cpu.tick()
	cpu.A = cpu.pull8()
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode68(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " PLA")
}

// ADC - immediate addressing.
func opcode69(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode69(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " ADC")
}

// ROR - adressing accumulator.
func opcode6A(cpu *CPU) {
	val := cpu.A
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.A = val
}

func disasmOpcode6A(cpu *CPU, pc uint16) []byte {
	return disasmAcc(cpu, pc, " ROR")
}

// ARR - immediate addressing.
func opcode6B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A &= val
	cpu.A >>= 1
	cpu.P = cpu.P.SetOverflow((cpu.A>>6)^(cpu.A>>5)&0x01 != 0)
	if cpu.P.Carry() {
		cpu.A |= 1 << 7
	}
	cpu.P.checkNZ(cpu.A)
	cpu.P = cpu.P.SetCarry(cpu.A&(1<<6) != 0)
}

func disasmOpcode6B(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*ARR")
}

// JMP - indirect addressing.
func opcode6C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	lo := cpu.Read8(oper)
	// 2 bytes address wrap around
	hi := cpu.Read8((0xff00 & oper) | (0x00ff & (oper + 1)))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.PC = oper
}

func disasmOpcode6C(cpu *CPU, pc uint16) []byte {
	return disasmInd(cpu, pc, " JMP")
}

// ADC - absolute addressing.
func opcode6D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode6D(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " ADC")
}

// ROR - absolute addressing.
func opcode6E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode6E(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " ROR")
}

// RRA - absolute addressing.
func opcode6F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode6F(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*RRA")
}

// BVS - relative addressing.
func opcode70(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.Overflow() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcode70(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BVS")
}

// ADC - indexed addressing (abs),Y.
func opcode71(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode71(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " ADC")
}

// JAM - immediate addressing.
func opcode72(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x72) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode72(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// RRA - indexed addressing (abs),Y.
func opcode73(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode73(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*RRA")
}

// NOP - indexed addressing: zeropage,X.
func opcode74(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

func disasmOpcode74(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*NOP")
}

// ADC - indexed addressing: zeropage,X.
func opcode75(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode75(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " ADC")
}

// ROR - indexed addressing: zeropage,X.
func opcode76(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode76(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " ROR")
}

// RRA - indexed addressing: zeropage,X.
func opcode77(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode77(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*RRA")
}

// SEI - implied addressing.
func opcode78(cpu *CPU) {
	cpu.P = cpu.P.SetIntDisable(true)
	cpu.tick()
}

func disasmOpcode78(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " SEI")
}

// ADC - absolute indexed Y.
func opcode79(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode79(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " ADC")
}

// NOP - implied addressing.
func opcode7A(cpu *CPU) {
	cpu.tick()
}

func disasmOpcode7A(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, "*NOP")
}

// RRA - absolute indexed Y.
func opcode7B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode7B(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*RRA")
}

// NOP - absolute indexed X.
func opcode7C(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

func disasmOpcode7C(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*NOP")
}

// ADC - absolute indexed X.
func opcode7D(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcode7D(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " ADC")
}

// ROR - absolute indexed X.
func opcode7E(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	cpu.Write8(oper, val)
}

func disasmOpcode7E(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " ROR")
}

// RRA - absolute indexed X.
func opcode7F(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	{
		carry := val & 0x01
		val >>= 1
		if cpu.P.Carry() {
			val |= 1 << 7
		}
		cpu.tick()
		cpu.P.checkNZ(val)
		cpu.P = cpu.P.SetCarry(carry != 0)
	}
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcode7F(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*RRA")
}

// NOP - immediate addressing.
func opcode80(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcode80(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*NOP")
}

// STA - indexed addressing (abs, X).
func opcode81(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode81(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " STA")
}

// NOP - immediate addressing.
func opcode82(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcode82(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*NOP")
}

// SAX - indexed addressing (abs, X).
func opcode83(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

func disasmOpcode83(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*SAX")
}

// STY - zero page addressing.
func opcode84(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

func disasmOpcode84(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " STY")
}

// STA - zero page addressing.
func opcode85(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode85(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " STA")
}

// STX - zero page addressing.
func opcode86(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.X)
}

func disasmOpcode86(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " STX")
}

// SAX - zero page addressing.
func opcode87(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

func disasmOpcode87(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*SAX")
}

// DEY - implied addressing.
func opcode88(cpu *CPU) {
	cpu.tick()
	cpu.Y--
	cpu.P.checkNZ(cpu.Y)
}

func disasmOpcode88(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " DEY")
}

// NOP - immediate addressing.
func opcode89(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcode89(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*NOP")
}

// TXA - implied addressing.
func opcode8A(cpu *CPU) {
	cpu.A = cpu.X
	cpu.P.checkNZ(cpu.X)
	cpu.tick()
}

func disasmOpcode8A(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " TXA")
}

// ANE - immediate addressing.
func opcode8B(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x8B (ANE)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode8B(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*ANE")
}

// STY - absolute addressing.
func opcode8C(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

func disasmOpcode8C(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " STY")
}

// STA - absolute addressing.
func opcode8D(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode8D(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " STA")
}

// STX - absolute addressing.
func opcode8E(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.X)
}

func disasmOpcode8E(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " STX")
}

// SAX - absolute addressing.
func opcode8F(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

func disasmOpcode8F(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*SAX")
}

// BCC - relative addressing.
func opcode90(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if !cpu.P.Carry() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcode90(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BCC")
}

// STA - indexed addressing (abs),Y.
func opcode91(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode91(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " STA")
}

// JAM - immediate addressing.
func opcode92(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0x92) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode92(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// SHA - indexed addressing (abs),Y.
func opcode93(cpu *CPU) {
	// default
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x93 (SHA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode93(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*SHA")
}

// STY - indexed addressing: zeropage,X.
func opcode94(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.Y)
}

func disasmOpcode94(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " STY")
}

// STA - indexed addressing: zeropage,X.
func opcode95(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode95(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " STA")
}

// STX - indexed addressing: zeropage,Y.
func opcode96(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.X)
}

func disasmOpcode96(cpu *CPU, pc uint16) []byte {
	return disasmZpy(cpu, pc, " STX")
}

// SAX - indexed addressing: zeropage,Y.
func opcode97(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	cpu.Write8(oper, cpu.A&cpu.X)
}

func disasmOpcode97(cpu *CPU, pc uint16) []byte {
	return disasmZpy(cpu, pc, "*SAX")
}

// TYA - implied addressing.
func opcode98(cpu *CPU) {
	cpu.A = cpu.Y
	cpu.P.checkNZ(cpu.Y)
	cpu.tick()
}

func disasmOpcode98(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " TYA")
}

// STA - absolute indexed Y.
func opcode99(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode99(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " STA")
}

// TXS - implied addressing.
func opcode9A(cpu *CPU) {
	cpu.SP = cpu.X
	cpu.tick()
}

func disasmOpcode9A(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " TXS")
}

// TAS - absolute indexed Y.
func opcode9B(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9B (TAS)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode9B(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*TAS")
}

// SHY - absolute indexed X.
func opcode9C(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9C (SHY)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode9C(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*SHY")
}

// STA - absolute indexed X.
func opcode9D(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	cpu.Write8(oper, cpu.A)
}

func disasmOpcode9D(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " STA")
}

// SHX - absolute indexed Y.
func opcode9E(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9E (SHX)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode9E(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*SHX")
}

// SHA - absolute indexed Y.
func opcode9F(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0x9F (SHA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcode9F(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*SHA")
}

// LDY - immediate addressing.
func opcodeA0(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA0(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " LDY")
}

// LDA - indexed addressing (abs, X).
func opcodeA1(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA1(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " LDA")
}

// LDX - immediate addressing.
func opcodeA2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA2(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " LDX")
}

// LAX - indexed addressing (abs, X).
func opcodeA3(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA3(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*LAX")
}

// LDY - zero page addressing.
func opcodeA4(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA4(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " LDY")
}

// LDA - zero page addressing.
func opcodeA5(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA5(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " LDA")
}

// LDX - zero page addressing.
func opcodeA6(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA6(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " LDX")
}

// LAX - zero page addressing.
func opcodeA7(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA7(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*LAX")
}

// TAY - implied addressing.
func opcodeA8(cpu *CPU) {
	cpu.Y = cpu.A
	cpu.P.checkNZ(cpu.A)
	cpu.tick()
}

func disasmOpcodeA8(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " TAY")
}

// LDA - immediate addressing.
func opcodeA9(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeA9(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " LDA")
}

// TAX - implied addressing.
func opcodeAA(cpu *CPU) {
	cpu.X = cpu.A
	cpu.P.checkNZ(cpu.A)
	cpu.tick()
}

func disasmOpcodeAA(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " TAX")
}

// LXA - immediate addressing.
func opcodeAB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("unsupported unstable opcode 0xAB (LXA)\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcodeAB(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*LXA")
}

// LDY - absolute addressing.
func opcodeAC(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeAC(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " LDY")
}

// LDA - absolute addressing.
func opcodeAD(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeAD(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " LDA")
}

// LDX - absolute addressing.
func opcodeAE(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeAE(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " LDX")
}

// LAX - absolute addressing.
func opcodeAF(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeAF(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*LAX")
}

// BCS - relative addressing.
func opcodeB0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.Carry() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcodeB0(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BCS")
}

// LDA - indexed addressing (abs),Y.
func opcodeB1(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB1(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " LDA")
}

// JAM - immediate addressing.
func opcodeB2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0xB2) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcodeB2(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// LAX - indexed addressing (abs),Y.
func opcodeB3(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB3(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*LAX")
}

// LDY - indexed addressing: zeropage,X.
func opcodeB4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB4(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " LDY")
}

// LDA - indexed addressing: zeropage,X.
func opcodeB5(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB5(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " LDA")
}

// LDX - indexed addressing: zeropage,Y.
func opcodeB6(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB6(cpu *CPU, pc uint16) []byte {
	return disasmZpy(cpu, pc, " LDX")
}

// LAX - indexed addressing: zeropage,Y.
func opcodeB7(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.Y)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB7(cpu *CPU, pc uint16) []byte {
	return disasmZpy(cpu, pc, "*LAX")
}

// CLV - implied addressing.
func opcodeB8(cpu *CPU) {
	cpu.P = cpu.P.SetOverflow(false)
	cpu.tick()
}

func disasmOpcodeB8(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " CLV")
}

// LDA - absolute indexed Y.
func opcodeB9(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeB9(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " LDA")
}

// TSX - implied addressing.
func opcodeBA(cpu *CPU) {
	cpu.X = cpu.SP
	cpu.P.checkNZ(cpu.SP)
	cpu.tick()
}

func disasmOpcodeBA(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " TSX")
}

// LAS - absolute indexed Y.
func opcodeBB(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = cpu.SP & val
	cpu.P.checkNZ(cpu.A)
	cpu.X = cpu.A
	cpu.SP = cpu.A
}

func disasmOpcodeBB(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*LAS")
}

// LDY - absolute indexed X.
func opcodeBC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.Y = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeBC(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " LDY")
}

// LDA - absolute indexed X.
func opcodeBD(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeBD(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " LDA")
}

// LDX - absolute indexed Y.
func opcodeBE(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeBE(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " LDX")
}

// LAX - absolute indexed Y.
func opcodeBF(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.A = val
	cpu.X = val
	cpu.P.checkNZ(val)
}

func disasmOpcodeBF(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*LAX")
}

// CPY - immediate addressing.
func opcodeC0(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.Y - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.Y)
}

func disasmOpcodeC0(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " CPY")
}

// CMP - indexed addressing (abs, X).
func opcodeC1(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeC1(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " CMP")
}

// NOP - immediate addressing.
func opcodeC2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcodeC2(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*NOP")
}

// DCP - indexed addressing (abs, X).
func opcodeC3(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeC3(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*DCP")
}

// CPY - zero page addressing.
func opcodeC4(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.Y - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.Y)
}

func disasmOpcodeC4(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " CPY")
}

// CMP - zero page addressing.
func opcodeC5(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeC5(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " CMP")
}

// DEC - zero page addressing.
func opcodeC6(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeC6(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " DEC")
}

// DCP - zero page addressing.
func opcodeC7(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeC7(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*DCP")
}

// INY - implied addressing.
func opcodeC8(cpu *CPU) {
	cpu.tick()
	cpu.Y++
	cpu.P.checkNZ(cpu.Y)
}

func disasmOpcodeC8(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " INY")
}

// CMP - immediate addressing.
func opcodeC9(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeC9(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " CMP")
}

// DEX - implied addressing.
func opcodeCA(cpu *CPU) {
	cpu.tick()
	cpu.X--
	cpu.P.checkNZ(cpu.X)
}

func disasmOpcodeCA(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " DEX")
}

// SBX - immediate addressing.
func opcodeCB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	ival := (int16(cpu.A) & int16(cpu.X)) - int16(val)
	cpu.X = uint8(ival)
	cpu.P.checkNZ(uint8(ival))
	cpu.P = cpu.P.SetCarry(ival >= 0)
}

func disasmOpcodeCB(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*SBX")
}

// CPY - absolute addressing.
func opcodeCC(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.Y - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.Y)
}

func disasmOpcodeCC(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " CPY")
}

// CMP - absolute addressing.
func opcodeCD(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeCD(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " CMP")
}

// DEC - absolute addressing.
func opcodeCE(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeCE(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " DEC")
}

// DCP - absolute addressing.
func opcodeCF(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeCF(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*DCP")
}

// BNE - relative addressing.
func opcodeD0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if !cpu.P.Zero() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcodeD0(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BNE")
}

// CMP - indexed addressing (abs),Y.
func opcodeD1(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeD1(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " CMP")
}

// JAM - immediate addressing.
func opcodeD2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0xD2) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcodeD2(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// DCP - indexed addressing (abs),Y.
func opcodeD3(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeD3(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*DCP")
}

// NOP - indexed addressing: zeropage,X.
func opcodeD4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

func disasmOpcodeD4(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*NOP")
}

// CMP - indexed addressing: zeropage,X.
func opcodeD5(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeD5(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " CMP")
}

// DEC - indexed addressing: zeropage,X.
func opcodeD6(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeD6(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " DEC")
}

// DCP - indexed addressing: zeropage,X.
func opcodeD7(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeD7(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*DCP")
}

// CLD - implied addressing.
func opcodeD8(cpu *CPU) {
	cpu.P = cpu.P.SetDecimal(false)
	cpu.tick()
}

func disasmOpcodeD8(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " CLD")
}

// CMP - absolute indexed Y.
func opcodeD9(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeD9(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " CMP")
}

// NOP - implied addressing.
func opcodeDA(cpu *CPU) {
	cpu.tick()
}

func disasmOpcodeDA(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, "*NOP")
}

// DCP - absolute indexed Y.
func opcodeDB(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeDB(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*DCP")
}

// NOP - absolute indexed X.
func opcodeDC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

func disasmOpcodeDC(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*NOP")
}

// CMP - absolute indexed X.
func opcodeDD(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
}

func disasmOpcodeDD(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " CMP")
}

// DEC - absolute indexed X.
func opcodeDE(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeDE(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " DEC")
}

// DCP - absolute indexed X.
func opcodeDF(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val--
	cpu.P.checkNZ(val)
	cpu.P.checkNZ(cpu.A - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.A)
	cpu.Write8(oper, val)
}

func disasmOpcodeDF(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*DCP")
}

// CPX - immediate addressing.
func opcodeE0(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.X - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.X)
}

func disasmOpcodeE0(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " CPX")
}

// SBC - indexed addressing (abs, X).
func opcodeE1(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeE1(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, " SBC")
}

// NOP - immediate addressing.
func opcodeE2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	cpu.tick()
}

func disasmOpcodeE2(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*NOP")
}

// ISB - indexed addressing (abs, X).
func opcodeE3(cpu *CPU) {
	cpu.tick()
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	oper = uint16(uint8(oper) + cpu.X)
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeE3(cpu *CPU, pc uint16) []byte {
	return disasmIzx(cpu, pc, "*ISB")
}

// CPX - zero page addressing.
func opcodeE4(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.X - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.X)
}

func disasmOpcodeE4(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " CPX")
}

// SBC - zero page addressing.
func opcodeE5(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeE5(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " SBC")
}

// INC - zero page addressing.
func opcodeE6(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeE6(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, " INC")
}

// ISB - zero page addressing.
func opcodeE7(cpu *CPU) {
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeE7(cpu *CPU, pc uint16) []byte {
	return disasmZpg(cpu, pc, "*ISB")
}

// INX - implied addressing.
func opcodeE8(cpu *CPU) {
	cpu.tick()
	cpu.X++
	cpu.P.checkNZ(cpu.X)
}

func disasmOpcodeE8(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " INX")
}

// SBC - immediate addressing.
func opcodeE9(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeE9(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, " SBC")
}

// NOP - implied addressing.
func opcodeEA(cpu *CPU) {
	cpu.tick()
}

func disasmOpcodeEA(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " NOP")
}

// SBC - immediate addressing.
func opcodeEB(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeEB(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*SBC")
}

// CPX - absolute addressing.
func opcodeEC(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.P.checkNZ(cpu.X - val)
	cpu.P = cpu.P.SetCarry(val <= cpu.X)
}

func disasmOpcodeEC(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " CPX")
}

// SBC - absolute addressing.
func opcodeED(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeED(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " SBC")
}

// INC - absolute addressing.
func opcodeEE(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeEE(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, " INC")
}

// ISB - absolute addressing.
func opcodeEF(cpu *CPU) {
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeEF(cpu *CPU, pc uint16) []byte {
	return disasmAbs(cpu, pc, "*ISB")
}

// BEQ - relative addressing.
func opcodeF0(cpu *CPU) {
	off := int8(cpu.Read8(cpu.PC))
	oper := uint16(int16(cpu.PC+1) + int16(off))
	_ = oper
	if cpu.P.Zero() { // do branch
		// A taken non-page-crossing branch ignores IRQ/NMI during its last
		// clock, so that next instruction executes before the IRQ.
		// Fixes 'branch_delays_irq' test.
		if cpu.runIRQ && !cpu.prevRunIRQ {
			cpu.runIRQ = false
		}
		cpu.tick()
		if 0xFF00&(cpu.PC+1) != 0xFF00&(oper) {
			cpu.tick()
		}
		cpu.PC = oper
		return
	}
	cpu.PC++
}

func disasmOpcodeF0(cpu *CPU, pc uint16) []byte {
	return disasmRel(cpu, pc, " BEQ")
}

// SBC - indexed addressing (abs),Y.
func opcodeF1(cpu *CPU) {
	// extra cycle for page cross
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	if 0xFF00&(oper) != 0xFF00&(oper+uint16(cpu.Y)) {
		cpu.tick()
	}
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeF1(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, " SBC")
}

// JAM - immediate addressing.
func opcodeF2(cpu *CPU) {
	oper := cpu.PC
	cpu.PC++
	_ = oper
	msg := fmt.Sprintf("Halt and catch fire!\nJAM(0xF2) called\nPC:0x%04X", cpu.PC)
	panic(msg)
}

func disasmOpcodeF2(cpu *CPU, pc uint16) []byte {
	return disasmImm(cpu, pc, "*JAM")
}

// ISB - indexed addressing (abs),Y.
func opcodeF3(cpu *CPU) {
	// extra cycle always
	oper := uint16(cpu.Read8(cpu.PC))
	cpu.PC++
	// read 16 bytes from the zero page, handling page wrap
	lo := cpu.Read8(oper)
	hi := cpu.Read8(uint16(uint8(oper) + 1))
	oper = uint16(hi)<<8 | uint16(lo)
	cpu.tick()
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeF3(cpu *CPU, pc uint16) []byte {
	return disasmIzy(cpu, pc, "*ISB")
}

// NOP - indexed addressing: zeropage,X.
func opcodeF4(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	cpu.tick()
}

func disasmOpcodeF4(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*NOP")
}

// SBC - indexed addressing: zeropage,X.
func opcodeF5(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeF5(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " SBC")
}

// INC - indexed addressing: zeropage,X.
func opcodeF6(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeF6(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, " INC")
}

// ISB - indexed addressing: zeropage,X.
func opcodeF7(cpu *CPU) {
	cpu.tick()
	addr := cpu.Read8(cpu.PC)
	cpu.PC++
	oper := uint16(addr) + uint16(cpu.X)
	oper &= 0xff
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeF7(cpu *CPU, pc uint16) []byte {
	return disasmZpx(cpu, pc, "*ISB")
}

// SED - implied addressing.
func opcodeF8(cpu *CPU) {
	cpu.P = cpu.P.SetDecimal(true)
	cpu.tick()
}

func disasmOpcodeF8(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, " SED")
}

// SBC - absolute indexed Y.
func opcodeF9(cpu *CPU) {
	// extra cycle for page cross
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.Y)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeF9(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, " SBC")
}

// NOP - implied addressing.
func opcodeFA(cpu *CPU) {
	cpu.tick()
}

func disasmOpcodeFA(cpu *CPU, pc uint16) []byte {
	return disasmImp(cpu, pc, "*NOP")
}

// ISB - absolute indexed Y.
func opcodeFB(cpu *CPU) {
	// default
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.Y)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeFB(cpu *CPU, pc uint16) []byte {
	return disasmAby(cpu, pc, "*ISB")
}

// NOP - absolute indexed X.
func opcodeFC(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	cpu.tick()
}

func disasmOpcodeFC(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*NOP")
}

// SBC - absolute indexed X.
func opcodeFD(cpu *CPU) {
	addr := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper := addr + uint16(cpu.X)
	if 0xFF00&(oper) != 0xFF00&(addr) {
		cpu.tick()
	}
	_ = oper
	val := cpu.Read8(oper)
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
}

func disasmOpcodeFD(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " SBC")
}

// INC - absolute indexed X.
func opcodeFE(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	cpu.Write8(oper, val)
}

func disasmOpcodeFE(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, " INC")
}

// ISB - absolute indexed X.
func opcodeFF(cpu *CPU) {
	cpu.tick()
	oper := cpu.Read16(cpu.PC)
	cpu.PC += 2
	oper += uint16(cpu.X)
	_ = oper
	val := cpu.Read8(oper)
	cpu.tick()
	val++
	cpu.P.checkNZ(val)
	final := val
	val ^= 0xff
	var carry uint16
	if cpu.P.Carry() {
		carry = 1
	}
	sum := uint16(cpu.A) + uint16(val) + uint16(carry)
	cpu.P.checkCV(cpu.A, val, sum)
	cpu.A = uint8(sum)
	cpu.P.checkNZ(cpu.A)
	val = final
	cpu.Write8(oper, val)
}

func disasmOpcodeFF(cpu *CPU, pc uint16) []byte {
	return disasmAbx(cpu, pc, "*ISB")
}

// list of unstable opcodes (unsupported)
var unstableOps = [256]uint8{
	0x02: 1, // JAM
	0x12: 1, // JAM
	0x22: 1, // JAM
	0x32: 1, // JAM
	0x42: 1, // JAM
	0x52: 1, // JAM
	0x62: 1, // JAM
	0x72: 1, // JAM
	0x8B: 1, // ANE
	0x92: 1, // JAM
	0x93: 1, // SHA
	0x9B: 1, // TAS
	0x9C: 1, // SHY
	0x9E: 1, // SHX
	0x9F: 1, // SHA
	0xAB: 1, // LXA
	0xB2: 1, // JAM
	0xD2: 1, // JAM
	0xF2: 1, // JAM
}

// nes 6502 opcodes table
var ops = [256]func(*CPU){
	BRK, opcode01, opcode02, opcode03, opcode04, opcode05, opcode06, opcode07, opcode08, opcode09, opcode0A, opcode0B, opcode0C, opcode0D, opcode0E, opcode0F,
	opcode10, opcode11, opcode12, opcode13, opcode14, opcode15, opcode16, opcode17, opcode18, opcode19, opcode1A, opcode1B, opcode1C, opcode1D, opcode1E, opcode1F,
	opcode20, opcode21, opcode22, opcode23, opcode24, opcode25, opcode26, opcode27, opcode28, opcode29, opcode2A, opcode2B, opcode2C, opcode2D, opcode2E, opcode2F,
	opcode30, opcode31, opcode32, opcode33, opcode34, opcode35, opcode36, opcode37, opcode38, opcode39, opcode3A, opcode3B, opcode3C, opcode3D, opcode3E, opcode3F,
	opcode40, opcode41, opcode42, opcode43, opcode44, opcode45, opcode46, opcode47, opcode48, opcode49, opcode4A, opcode4B, opcode4C, opcode4D, opcode4E, opcode4F,
	opcode50, opcode51, opcode52, opcode53, opcode54, opcode55, opcode56, opcode57, opcode58, opcode59, opcode5A, opcode5B, opcode5C, opcode5D, opcode5E, opcode5F,
	opcode60, opcode61, opcode62, opcode63, opcode64, opcode65, opcode66, opcode67, opcode68, opcode69, opcode6A, opcode6B, opcode6C, opcode6D, opcode6E, opcode6F,
	opcode70, opcode71, opcode72, opcode73, opcode74, opcode75, opcode76, opcode77, opcode78, opcode79, opcode7A, opcode7B, opcode7C, opcode7D, opcode7E, opcode7F,
	opcode80, opcode81, opcode82, opcode83, opcode84, opcode85, opcode86, opcode87, opcode88, opcode89, opcode8A, opcode8B, opcode8C, opcode8D, opcode8E, opcode8F,
	opcode90, opcode91, opcode92, opcode93, opcode94, opcode95, opcode96, opcode97, opcode98, opcode99, opcode9A, opcode9B, opcode9C, opcode9D, opcode9E, opcode9F,
	opcodeA0, opcodeA1, opcodeA2, opcodeA3, opcodeA4, opcodeA5, opcodeA6, opcodeA7, opcodeA8, opcodeA9, opcodeAA, opcodeAB, opcodeAC, opcodeAD, opcodeAE, opcodeAF,
	opcodeB0, opcodeB1, opcodeB2, opcodeB3, opcodeB4, opcodeB5, opcodeB6, opcodeB7, opcodeB8, opcodeB9, opcodeBA, opcodeBB, opcodeBC, opcodeBD, opcodeBE, opcodeBF,
	opcodeC0, opcodeC1, opcodeC2, opcodeC3, opcodeC4, opcodeC5, opcodeC6, opcodeC7, opcodeC8, opcodeC9, opcodeCA, opcodeCB, opcodeCC, opcodeCD, opcodeCE, opcodeCF,
	opcodeD0, opcodeD1, opcodeD2, opcodeD3, opcodeD4, opcodeD5, opcodeD6, opcodeD7, opcodeD8, opcodeD9, opcodeDA, opcodeDB, opcodeDC, opcodeDD, opcodeDE, opcodeDF,
	opcodeE0, opcodeE1, opcodeE2, opcodeE3, opcodeE4, opcodeE5, opcodeE6, opcodeE7, opcodeE8, opcodeE9, opcodeEA, opcodeEB, opcodeEC, opcodeED, opcodeEE, opcodeEF,
	opcodeF0, opcodeF1, opcodeF2, opcodeF3, opcodeF4, opcodeF5, opcodeF6, opcodeF7, opcodeF8, opcodeF9, opcodeFA, opcodeFB, opcodeFC, opcodeFD, opcodeFE, opcodeFF,
}

func disasmAbs(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	oper2 := cpu.Bus.Peek8(pc + 2)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%02X ", oper2)
	fmt.Fprintf(&bb, "%*s", 0, "")
	oper16 := uint16(oper1) | uint16(oper2)<<8
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " $%04X", oper16)
	return bb.Bytes()
}

func disasmAbx(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	oper2 := cpu.Bus.Peek8(pc + 2)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%02X ", oper2)
	fmt.Fprintf(&bb, "%*s", 0, "")
	oper16 := uint16(oper1) | uint16(oper2)<<8
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " $%04X,X", oper16)
	return bb.Bytes()
}

func disasmAby(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	oper2 := cpu.Bus.Peek8(pc + 2)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%02X ", oper2)
	fmt.Fprintf(&bb, "%*s", 0, "")
	oper16 := uint16(oper1) | uint16(oper2)<<8
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " $%04X,Y", oper16)
	return bb.Bytes()
}

func disasmAcc(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%*s", 6, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " A")
	return bb.Bytes()
}

func disasmImm(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " #$%02X", oper1)
	return bb.Bytes()
}

func disasmImp(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%*s", 6, "")
	bb.WriteString(opname)
	return bb.Bytes()
}

func disasmInd(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	oper2 := cpu.Bus.Peek8(pc + 2)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%02X ", oper2)
	fmt.Fprintf(&bb, "%*s", 0, "")
	oper16 := uint16(oper1) | uint16(oper2)<<8
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " ($%04X)", oper16)
	return bb.Bytes()
}

func disasmIzx(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " ($%02X,X)", oper1)
	return bb.Bytes()
}

func disasmIzy(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " ($%02X),Y", oper1)
	return bb.Bytes()
}

func disasmRel(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	off := int16(int8(oper1))
	oper := uint16(int16(pc+2) + off)
	fmt.Fprintf(&bb, " $%04X", oper)
	return bb.Bytes()
}

func disasmZpg(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " $%02X", oper1)
	return bb.Bytes()
}

func disasmZpx(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " $%02X", oper1)
	return bb.Bytes()
}

func disasmZpy(cpu *CPU, pc uint16, opname string) []byte {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "%04X  ", pc)
	oper0 := cpu.Bus.Peek8(pc + 0)
	oper1 := cpu.Bus.Peek8(pc + 1)
	fmt.Fprintf(&bb, "%02X ", oper0)
	fmt.Fprintf(&bb, "%02X ", oper1)
	fmt.Fprintf(&bb, "%*s", 3, "")
	bb.WriteString(opname)
	fmt.Fprintf(&bb, " $%02X", oper1)
	return bb.Bytes()
}

// nes 6502 opcodes disassembly table
var disasmOps = [256]func(*CPU, uint16) []byte{
	disasmOpcode00, disasmOpcode01, disasmOpcode02, disasmOpcode03, disasmOpcode04, disasmOpcode05, disasmOpcode06, disasmOpcode07, disasmOpcode08, disasmOpcode09, disasmOpcode0A, disasmOpcode0B, disasmOpcode0C, disasmOpcode0D, disasmOpcode0E, disasmOpcode0F,
	disasmOpcode10, disasmOpcode11, disasmOpcode12, disasmOpcode13, disasmOpcode14, disasmOpcode15, disasmOpcode16, disasmOpcode17, disasmOpcode18, disasmOpcode19, disasmOpcode1A, disasmOpcode1B, disasmOpcode1C, disasmOpcode1D, disasmOpcode1E, disasmOpcode1F,
	disasmOpcode20, disasmOpcode21, disasmOpcode22, disasmOpcode23, disasmOpcode24, disasmOpcode25, disasmOpcode26, disasmOpcode27, disasmOpcode28, disasmOpcode29, disasmOpcode2A, disasmOpcode2B, disasmOpcode2C, disasmOpcode2D, disasmOpcode2E, disasmOpcode2F,
	disasmOpcode30, disasmOpcode31, disasmOpcode32, disasmOpcode33, disasmOpcode34, disasmOpcode35, disasmOpcode36, disasmOpcode37, disasmOpcode38, disasmOpcode39, disasmOpcode3A, disasmOpcode3B, disasmOpcode3C, disasmOpcode3D, disasmOpcode3E, disasmOpcode3F,
	disasmOpcode40, disasmOpcode41, disasmOpcode42, disasmOpcode43, disasmOpcode44, disasmOpcode45, disasmOpcode46, disasmOpcode47, disasmOpcode48, disasmOpcode49, disasmOpcode4A, disasmOpcode4B, disasmOpcode4C, disasmOpcode4D, disasmOpcode4E, disasmOpcode4F,
	disasmOpcode50, disasmOpcode51, disasmOpcode52, disasmOpcode53, disasmOpcode54, disasmOpcode55, disasmOpcode56, disasmOpcode57, disasmOpcode58, disasmOpcode59, disasmOpcode5A, disasmOpcode5B, disasmOpcode5C, disasmOpcode5D, disasmOpcode5E, disasmOpcode5F,
	disasmOpcode60, disasmOpcode61, disasmOpcode62, disasmOpcode63, disasmOpcode64, disasmOpcode65, disasmOpcode66, disasmOpcode67, disasmOpcode68, disasmOpcode69, disasmOpcode6A, disasmOpcode6B, disasmOpcode6C, disasmOpcode6D, disasmOpcode6E, disasmOpcode6F,
	disasmOpcode70, disasmOpcode71, disasmOpcode72, disasmOpcode73, disasmOpcode74, disasmOpcode75, disasmOpcode76, disasmOpcode77, disasmOpcode78, disasmOpcode79, disasmOpcode7A, disasmOpcode7B, disasmOpcode7C, disasmOpcode7D, disasmOpcode7E, disasmOpcode7F,
	disasmOpcode80, disasmOpcode81, disasmOpcode82, disasmOpcode83, disasmOpcode84, disasmOpcode85, disasmOpcode86, disasmOpcode87, disasmOpcode88, disasmOpcode89, disasmOpcode8A, disasmOpcode8B, disasmOpcode8C, disasmOpcode8D, disasmOpcode8E, disasmOpcode8F,
	disasmOpcode90, disasmOpcode91, disasmOpcode92, disasmOpcode93, disasmOpcode94, disasmOpcode95, disasmOpcode96, disasmOpcode97, disasmOpcode98, disasmOpcode99, disasmOpcode9A, disasmOpcode9B, disasmOpcode9C, disasmOpcode9D, disasmOpcode9E, disasmOpcode9F,
	disasmOpcodeA0, disasmOpcodeA1, disasmOpcodeA2, disasmOpcodeA3, disasmOpcodeA4, disasmOpcodeA5, disasmOpcodeA6, disasmOpcodeA7, disasmOpcodeA8, disasmOpcodeA9, disasmOpcodeAA, disasmOpcodeAB, disasmOpcodeAC, disasmOpcodeAD, disasmOpcodeAE, disasmOpcodeAF,
	disasmOpcodeB0, disasmOpcodeB1, disasmOpcodeB2, disasmOpcodeB3, disasmOpcodeB4, disasmOpcodeB5, disasmOpcodeB6, disasmOpcodeB7, disasmOpcodeB8, disasmOpcodeB9, disasmOpcodeBA, disasmOpcodeBB, disasmOpcodeBC, disasmOpcodeBD, disasmOpcodeBE, disasmOpcodeBF,
	disasmOpcodeC0, disasmOpcodeC1, disasmOpcodeC2, disasmOpcodeC3, disasmOpcodeC4, disasmOpcodeC5, disasmOpcodeC6, disasmOpcodeC7, disasmOpcodeC8, disasmOpcodeC9, disasmOpcodeCA, disasmOpcodeCB, disasmOpcodeCC, disasmOpcodeCD, disasmOpcodeCE, disasmOpcodeCF,
	disasmOpcodeD0, disasmOpcodeD1, disasmOpcodeD2, disasmOpcodeD3, disasmOpcodeD4, disasmOpcodeD5, disasmOpcodeD6, disasmOpcodeD7, disasmOpcodeD8, disasmOpcodeD9, disasmOpcodeDA, disasmOpcodeDB, disasmOpcodeDC, disasmOpcodeDD, disasmOpcodeDE, disasmOpcodeDF,
	disasmOpcodeE0, disasmOpcodeE1, disasmOpcodeE2, disasmOpcodeE3, disasmOpcodeE4, disasmOpcodeE5, disasmOpcodeE6, disasmOpcodeE7, disasmOpcodeE8, disasmOpcodeE9, disasmOpcodeEA, disasmOpcodeEB, disasmOpcodeEC, disasmOpcodeED, disasmOpcodeEE, disasmOpcodeEF,
	disasmOpcodeF0, disasmOpcodeF1, disasmOpcodeF2, disasmOpcodeF3, disasmOpcodeF4, disasmOpcodeF5, disasmOpcodeF6, disasmOpcodeF7, disasmOpcodeF8, disasmOpcodeF9, disasmOpcodeFA, disasmOpcodeFB, disasmOpcodeFC, disasmOpcodeFD, disasmOpcodeFE, disasmOpcodeFF,
}

var opcodeNames = [256]string{
	"BRK", "ORA", "JAM", "SLO", "NOP", "ORA", "ASL", "SLO", "PHP", "ORA", "ASL", "ANC", "NOP", "ORA", "ASL", "SLO",
	"BPL", "ORA", "JAM", "SLO", "NOP", "ORA", "ASL", "SLO", "CLC", "ORA", "NOP", "SLO", "NOP", "ORA", "ASL", "SLO",
	"JSR", "AND", "JAM", "RLA", "BIT", "AND", "ROL", "RLA", "PLP", "AND", "ROL", "ANC", "BIT", "AND", "ROL", "RLA",
	"BMI", "AND", "JAM", "RLA", "NOP", "AND", "ROL", "RLA", "SEC", "AND", "NOP", "RLA", "NOP", "AND", "ROL", "RLA",
	"RTI", "EOR", "JAM", "SRE", "NOP", "EOR", "LSR", "SRE", "PHA", "EOR", "LSR", "ALR", "JMP", "EOR", "LSR", "SRE",
	"BVC", "EOR", "JAM", "SRE", "NOP", "EOR", "LSR", "SRE", "CLI", "EOR", "NOP", "SRE", "NOP", "EOR", "LSR", "SRE",
	"RTS", "ADC", "JAM", "RRA", "NOP", "ADC", "ROR", "RRA", "PLA", "ADC", "ROR", "ARR", "JMP", "ADC", "ROR", "RRA",
	"BVS", "ADC", "JAM", "RRA", "NOP", "ADC", "ROR", "RRA", "SEI", "ADC", "NOP", "RRA", "NOP", "ADC", "ROR", "RRA",
	"NOP", "STA", "NOP", "SAX", "STY", "STA", "STX", "SAX", "DEY", "NOP", "TXA", "ANE", "STY", "STA", "STX", "SAX",
	"BCC", "STA", "JAM", "SHA", "STY", "STA", "STX", "SAX", "TYA", "STA", "TXS", "TAS", "SHY", "STA", "SHX", "SHA",
	"LDY", "LDA", "LDX", "LAX", "LDY", "LDA", "LDX", "LAX", "TAY", "LDA", "TAX", "LXA", "LDY", "LDA", "LDX", "LAX",
	"BCS", "LDA", "JAM", "LAX", "LDY", "LDA", "LDX", "LAX", "CLV", "LDA", "TSX", "LAS", "LDY", "LDA", "LDX", "LAX",
	"CPY", "CMP", "NOP", "DCP", "CPY", "CMP", "DEC", "DCP", "INY", "CMP", "DEX", "SBX", "CPY", "CMP", "DEC", "DCP",
	"BNE", "CMP", "JAM", "DCP", "NOP", "CMP", "DEC", "DCP", "CLD", "CMP", "NOP", "DCP", "NOP", "CMP", "DEC", "DCP",
	"CPX", "SBC", "NOP", "ISB", "CPX", "SBC", "INC", "ISB", "INX", "SBC", "NOP", "SBC", "CPX", "SBC", "INC", "ISB",
	"BEQ", "SBC", "JAM", "ISB", "NOP", "SBC", "INC", "ISB", "SED", "SBC", "NOP", "ISB", "NOP", "SBC", "INC", "ISB",
}
