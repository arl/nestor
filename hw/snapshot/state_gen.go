package snapshot

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *CPU) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PC":
			z.PC, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "PC")
				return
			}
		case "SP":
			z.SP, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "SP")
				return
			}
		case "P":
			z.P, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "P")
				return
			}
		case "A":
			z.A, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "A")
				return
			}
		case "X":
			z.X, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "Y":
			z.Y, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "Cycles":
			z.Cycles, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Cycles")
				return
			}
		case "MasterClock":
			z.MasterClock, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "MasterClock")
				return
			}
		case "IRQFlag":
			z.IRQFlag, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "IRQFlag")
				return
			}
		case "RunIRQ":
			z.RunIRQ, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "RunIRQ")
				return
			}
		case "PrevRunIRQ":
			z.PrevRunIRQ, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "PrevRunIRQ")
				return
			}
		case "NMIFlag":
			z.NMIFlag, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NMIFlag")
				return
			}
		case "PrevNeedNMI":
			z.PrevNeedNMI, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "PrevNeedNMI")
				return
			}
		case "PrevNMIFlag":
			z.PrevNMIFlag, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "PrevNMIFlag")
				return
			}
		case "NeedNMI":
			z.NeedNMI, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NeedNMI")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CPU) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 15
	// write "PC"
	err = en.Append(0x8f, 0xa2, 0x50, 0x43)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.PC)
	if err != nil {
		err = msgp.WrapError(err, "PC")
		return
	}
	// write "SP"
	err = en.Append(0xa2, 0x53, 0x50)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.SP)
	if err != nil {
		err = msgp.WrapError(err, "SP")
		return
	}
	// write "P"
	err = en.Append(0xa1, 0x50)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.P)
	if err != nil {
		err = msgp.WrapError(err, "P")
		return
	}
	// write "A"
	err = en.Append(0xa1, 0x41)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.A)
	if err != nil {
		err = msgp.WrapError(err, "A")
		return
	}
	// write "X"
	err = en.Append(0xa1, 0x58)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.X)
	if err != nil {
		err = msgp.WrapError(err, "X")
		return
	}
	// write "Y"
	err = en.Append(0xa1, 0x59)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.Y)
	if err != nil {
		err = msgp.WrapError(err, "Y")
		return
	}
	// write "Cycles"
	err = en.Append(0xa6, 0x43, 0x79, 0x63, 0x6c, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Cycles)
	if err != nil {
		err = msgp.WrapError(err, "Cycles")
		return
	}
	// write "MasterClock"
	err = en.Append(0xab, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6c, 0x6f, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.MasterClock)
	if err != nil {
		err = msgp.WrapError(err, "MasterClock")
		return
	}
	// write "IRQFlag"
	err = en.Append(0xa7, 0x49, 0x52, 0x51, 0x46, 0x6c, 0x61, 0x67)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.IRQFlag)
	if err != nil {
		err = msgp.WrapError(err, "IRQFlag")
		return
	}
	// write "RunIRQ"
	err = en.Append(0xa6, 0x52, 0x75, 0x6e, 0x49, 0x52, 0x51)
	if err != nil {
		return
	}
	err = en.WriteBool(z.RunIRQ)
	if err != nil {
		err = msgp.WrapError(err, "RunIRQ")
		return
	}
	// write "PrevRunIRQ"
	err = en.Append(0xaa, 0x50, 0x72, 0x65, 0x76, 0x52, 0x75, 0x6e, 0x49, 0x52, 0x51)
	if err != nil {
		return
	}
	err = en.WriteBool(z.PrevRunIRQ)
	if err != nil {
		err = msgp.WrapError(err, "PrevRunIRQ")
		return
	}
	// write "NMIFlag"
	err = en.Append(0xa7, 0x4e, 0x4d, 0x49, 0x46, 0x6c, 0x61, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBool(z.NMIFlag)
	if err != nil {
		err = msgp.WrapError(err, "NMIFlag")
		return
	}
	// write "PrevNeedNMI"
	err = en.Append(0xab, 0x50, 0x72, 0x65, 0x76, 0x4e, 0x65, 0x65, 0x64, 0x4e, 0x4d, 0x49)
	if err != nil {
		return
	}
	err = en.WriteBool(z.PrevNeedNMI)
	if err != nil {
		err = msgp.WrapError(err, "PrevNeedNMI")
		return
	}
	// write "PrevNMIFlag"
	err = en.Append(0xab, 0x50, 0x72, 0x65, 0x76, 0x4e, 0x4d, 0x49, 0x46, 0x6c, 0x61, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBool(z.PrevNMIFlag)
	if err != nil {
		err = msgp.WrapError(err, "PrevNMIFlag")
		return
	}
	// write "NeedNMI"
	err = en.Append(0xa7, 0x4e, 0x65, 0x65, 0x64, 0x4e, 0x4d, 0x49)
	if err != nil {
		return
	}
	err = en.WriteBool(z.NeedNMI)
	if err != nil {
		err = msgp.WrapError(err, "NeedNMI")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CPU) Msgsize() (s int) {
	s = 1 + 3 + msgp.Uint16Size + 3 + msgp.Uint8Size + 2 + msgp.Uint8Size + 2 + msgp.Uint8Size + 2 + msgp.Uint8Size + 2 + msgp.Uint8Size + 7 + msgp.Int64Size + 12 + msgp.Int64Size + 8 + msgp.Uint8Size + 7 + msgp.BoolSize + 11 + msgp.BoolSize + 8 + msgp.BoolSize + 12 + msgp.BoolSize + 12 + msgp.BoolSize + 8 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DMA) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DMCRunning":
			z.DMCRunning, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DMCRunning")
				return
			}
		case "AbortDMC":
			z.AbortDMC, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AbortDMC")
				return
			}
		case "OAMRunning":
			z.OAMRunning, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "OAMRunning")
				return
			}
		case "DummyCycle":
			z.DummyCycle, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DummyCycle")
				return
			}
		case "NeedHalt":
			z.NeedHalt, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NeedHalt")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DMA) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "DMCRunning"
	err = en.Append(0x85, 0xaa, 0x44, 0x4d, 0x43, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBool(z.DMCRunning)
	if err != nil {
		err = msgp.WrapError(err, "DMCRunning")
		return
	}
	// write "AbortDMC"
	err = en.Append(0xa8, 0x41, 0x62, 0x6f, 0x72, 0x74, 0x44, 0x4d, 0x43)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AbortDMC)
	if err != nil {
		err = msgp.WrapError(err, "AbortDMC")
		return
	}
	// write "OAMRunning"
	err = en.Append(0xaa, 0x4f, 0x41, 0x4d, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteBool(z.OAMRunning)
	if err != nil {
		err = msgp.WrapError(err, "OAMRunning")
		return
	}
	// write "DummyCycle"
	err = en.Append(0xaa, 0x44, 0x75, 0x6d, 0x6d, 0x79, 0x43, 0x79, 0x63, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.DummyCycle)
	if err != nil {
		err = msgp.WrapError(err, "DummyCycle")
		return
	}
	// write "NeedHalt"
	err = en.Append(0xa8, 0x4e, 0x65, 0x65, 0x64, 0x48, 0x61, 0x6c, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.NeedHalt)
	if err != nil {
		err = msgp.WrapError(err, "NeedHalt")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DMA) Msgsize() (s int) {
	s = 1 + 11 + msgp.BoolSize + 9 + msgp.BoolSize + 11 + msgp.BoolSize + 11 + msgp.BoolSize + 9 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NES) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Version":
			z.Version, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "CPU":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPU)
				}
				err = z.CPU.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		case "RAM":
			err = dc.ReadExactBytes((z.RAM)[:])
			if err != nil {
				err = msgp.WrapError(err, "RAM")
				return
			}
		case "DMA":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DMA")
					return
				}
				z.DMA = nil
			} else {
				if z.DMA == nil {
					z.DMA = new(DMA)
				}
				err = z.DMA.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "DMA")
					return
				}
			}
		case "PPU":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PPU")
					return
				}
				z.PPU = nil
			} else {
				if z.PPU == nil {
					z.PPU = new(PPU)
				}
				err = z.PPU.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "PPU")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NES) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "Version"
	err = en.Append(0x85, 0xa7, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "CPU"
	err = en.Append(0xa3, 0x43, 0x50, 0x55)
	if err != nil {
		return
	}
	if z.CPU == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.CPU.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "CPU")
			return
		}
	}
	// write "RAM"
	err = en.Append(0xa3, 0x52, 0x41, 0x4d)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.RAM)[:])
	if err != nil {
		err = msgp.WrapError(err, "RAM")
		return
	}
	// write "DMA"
	err = en.Append(0xa3, 0x44, 0x4d, 0x41)
	if err != nil {
		return
	}
	if z.DMA == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.DMA.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "DMA")
			return
		}
	}
	// write "PPU"
	err = en.Append(0xa3, 0x50, 0x50, 0x55)
	if err != nil {
		return
	}
	if z.PPU == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.PPU.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PPU")
			return
		}
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NES) Msgsize() (s int) {
	s = 1 + 8 + msgp.IntSize + 4
	if z.CPU == nil {
		s += msgp.NilSize
	} else {
		s += z.CPU.Msgsize()
	}
	s += 4 + msgp.ArrayHeaderSize + (0x800 * (msgp.Uint8Size)) + 4
	if z.DMA == nil {
		s += msgp.NilSize
	} else {
		s += z.DMA.Msgsize()
	}
	s += 4
	if z.PPU == nil {
		s += msgp.NilSize
	} else {
		s += z.PPU.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PPU) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Palette":
			err = dc.ReadExactBytes((z.Palette)[:])
			if err != nil {
				err = msgp.WrapError(err, "Palette")
				return
			}
		case "OAMMem":
			err = dc.ReadExactBytes((z.OAMMem)[:])
			if err != nil {
				err = msgp.WrapError(err, "OAMMem")
				return
			}
		case "OAM":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OAM")
				return
			}
			if zb0002 != uint32(8) {
				err = msgp.ArrayError{Wanted: uint32(8), Got: zb0002}
				return
			}
			for za0003 := range z.OAM {
				err = z.OAM[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OAM", za0003)
					return
				}
			}
		case "OAM2":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OAM2")
				return
			}
			if zb0003 != uint32(8) {
				err = msgp.ArrayError{Wanted: uint32(8), Got: zb0003}
				return
			}
			for za0004 := range z.OAM2 {
				err = z.OAM2[za0004].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OAM2", za0004)
					return
				}
			}
		case "OpenBus":
			z.OpenBus, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "OpenBus")
				return
			}
		case "OpenBusDecayBuf":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OpenBusDecayBuf")
				return
			}
			if zb0004 != uint32(8) {
				err = msgp.ArrayError{Wanted: uint32(8), Got: zb0004}
				return
			}
			for za0005 := range z.OpenBusDecayBuf {
				z.OpenBusDecayBuf[za0005], err = dc.ReadUint32()
				if err != nil {
					err = msgp.WrapError(err, "OpenBusDecayBuf", za0005)
					return
				}
			}
		case "BusAddr":
			z.BusAddr, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "BusAddr")
				return
			}
		case "OAMAddr":
			z.OAMAddr, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "OAMAddr")
				return
			}
		case "VRAMAddr":
			z.VRAMAddr, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "VRAMAddr")
				return
			}
		case "VRAMTemp":
			z.VRAMTemp, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "VRAMTemp")
				return
			}
		case "WriteLatch":
			z.WriteLatch, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "WriteLatch")
				return
			}
		case "PPUDataBuf":
			z.PPUDataBuf, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "PPUDataBuf")
				return
			}
		case "PPUBgRegs":
			err = z.PPUBgRegs.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "PPUBgRegs")
				return
			}
		case "PPUCTRL":
			z.PPUCTRL, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "PPUCTRL")
				return
			}
		case "PPUMASK":
			z.PPUMASK, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "PPUMASK")
				return
			}
		case "PPUSTATUS":
			z.PPUSTATUS, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "PPUSTATUS")
				return
			}
		case "MasterClock":
			z.MasterClock, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MasterClock")
				return
			}
		case "Cycle":
			z.Cycle, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Cycle")
				return
			}
		case "Scanline":
			z.Scanline, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Scanline")
				return
			}
		case "FrameCount":
			z.FrameCount, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "FrameCount")
				return
			}
		case "OddFrame":
			z.OddFrame, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "OddFrame")
				return
			}
		case "PreventVBlank":
			z.PreventVBlank, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "PreventVBlank")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PPU) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 22
	// write "Palette"
	err = en.Append(0xde, 0x0, 0x16, 0xa7, 0x50, 0x61, 0x6c, 0x65, 0x74, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Palette)[:])
	if err != nil {
		err = msgp.WrapError(err, "Palette")
		return
	}
	// write "OAMMem"
	err = en.Append(0xa6, 0x4f, 0x41, 0x4d, 0x4d, 0x65, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.OAMMem)[:])
	if err != nil {
		err = msgp.WrapError(err, "OAMMem")
		return
	}
	// write "OAM"
	err = en.Append(0xa3, 0x4f, 0x41, 0x4d)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(8))
	if err != nil {
		err = msgp.WrapError(err, "OAM")
		return
	}
	for za0003 := range z.OAM {
		err = z.OAM[za0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "OAM", za0003)
			return
		}
	}
	// write "OAM2"
	err = en.Append(0xa4, 0x4f, 0x41, 0x4d, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(8))
	if err != nil {
		err = msgp.WrapError(err, "OAM2")
		return
	}
	for za0004 := range z.OAM2 {
		err = z.OAM2[za0004].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "OAM2", za0004)
			return
		}
	}
	// write "OpenBus"
	err = en.Append(0xa7, 0x4f, 0x70, 0x65, 0x6e, 0x42, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.OpenBus)
	if err != nil {
		err = msgp.WrapError(err, "OpenBus")
		return
	}
	// write "OpenBusDecayBuf"
	err = en.Append(0xaf, 0x4f, 0x70, 0x65, 0x6e, 0x42, 0x75, 0x73, 0x44, 0x65, 0x63, 0x61, 0x79, 0x42, 0x75, 0x66)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(8))
	if err != nil {
		err = msgp.WrapError(err, "OpenBusDecayBuf")
		return
	}
	for za0005 := range z.OpenBusDecayBuf {
		err = en.WriteUint32(z.OpenBusDecayBuf[za0005])
		if err != nil {
			err = msgp.WrapError(err, "OpenBusDecayBuf", za0005)
			return
		}
	}
	// write "BusAddr"
	err = en.Append(0xa7, 0x42, 0x75, 0x73, 0x41, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.BusAddr)
	if err != nil {
		err = msgp.WrapError(err, "BusAddr")
		return
	}
	// write "OAMAddr"
	err = en.Append(0xa7, 0x4f, 0x41, 0x4d, 0x41, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.OAMAddr)
	if err != nil {
		err = msgp.WrapError(err, "OAMAddr")
		return
	}
	// write "VRAMAddr"
	err = en.Append(0xa8, 0x56, 0x52, 0x41, 0x4d, 0x41, 0x64, 0x64, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.VRAMAddr)
	if err != nil {
		err = msgp.WrapError(err, "VRAMAddr")
		return
	}
	// write "VRAMTemp"
	err = en.Append(0xa8, 0x56, 0x52, 0x41, 0x4d, 0x54, 0x65, 0x6d, 0x70)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.VRAMTemp)
	if err != nil {
		err = msgp.WrapError(err, "VRAMTemp")
		return
	}
	// write "WriteLatch"
	err = en.Append(0xaa, 0x57, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x61, 0x74, 0x63, 0x68)
	if err != nil {
		return
	}
	err = en.WriteBool(z.WriteLatch)
	if err != nil {
		err = msgp.WrapError(err, "WriteLatch")
		return
	}
	// write "PPUDataBuf"
	err = en.Append(0xaa, 0x50, 0x50, 0x55, 0x44, 0x61, 0x74, 0x61, 0x42, 0x75, 0x66)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.PPUDataBuf)
	if err != nil {
		err = msgp.WrapError(err, "PPUDataBuf")
		return
	}
	// write "PPUBgRegs"
	err = en.Append(0xa9, 0x50, 0x50, 0x55, 0x42, 0x67, 0x52, 0x65, 0x67, 0x73)
	if err != nil {
		return
	}
	err = z.PPUBgRegs.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "PPUBgRegs")
		return
	}
	// write "PPUCTRL"
	err = en.Append(0xa7, 0x50, 0x50, 0x55, 0x43, 0x54, 0x52, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.PPUCTRL)
	if err != nil {
		err = msgp.WrapError(err, "PPUCTRL")
		return
	}
	// write "PPUMASK"
	err = en.Append(0xa7, 0x50, 0x50, 0x55, 0x4d, 0x41, 0x53, 0x4b)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.PPUMASK)
	if err != nil {
		err = msgp.WrapError(err, "PPUMASK")
		return
	}
	// write "PPUSTATUS"
	err = en.Append(0xa9, 0x50, 0x50, 0x55, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.PPUSTATUS)
	if err != nil {
		err = msgp.WrapError(err, "PPUSTATUS")
		return
	}
	// write "MasterClock"
	err = en.Append(0xab, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6c, 0x6f, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.MasterClock)
	if err != nil {
		err = msgp.WrapError(err, "MasterClock")
		return
	}
	// write "Cycle"
	err = en.Append(0xa5, 0x43, 0x79, 0x63, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Cycle)
	if err != nil {
		err = msgp.WrapError(err, "Cycle")
		return
	}
	// write "Scanline"
	err = en.Append(0xa8, 0x53, 0x63, 0x61, 0x6e, 0x6c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Scanline)
	if err != nil {
		err = msgp.WrapError(err, "Scanline")
		return
	}
	// write "FrameCount"
	err = en.Append(0xaa, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.FrameCount)
	if err != nil {
		err = msgp.WrapError(err, "FrameCount")
		return
	}
	// write "OddFrame"
	err = en.Append(0xa8, 0x4f, 0x64, 0x64, 0x46, 0x72, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.OddFrame)
	if err != nil {
		err = msgp.WrapError(err, "OddFrame")
		return
	}
	// write "PreventVBlank"
	err = en.Append(0xad, 0x50, 0x72, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x56, 0x42, 0x6c, 0x61, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteBool(z.PreventVBlank)
	if err != nil {
		err = msgp.WrapError(err, "PreventVBlank")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PPU) Msgsize() (s int) {
	s = 3 + 8 + msgp.ArrayHeaderSize + (0x20 * (msgp.Uint8Size)) + 7 + msgp.ArrayHeaderSize + (0x100 * (msgp.Uint8Size)) + 4 + msgp.ArrayHeaderSize
	for za0003 := range z.OAM {
		s += z.OAM[za0003].Msgsize()
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0004 := range z.OAM2 {
		s += z.OAM2[za0004].Msgsize()
	}
	s += 8 + msgp.Uint8Size + 16 + msgp.ArrayHeaderSize + (8 * (msgp.Uint32Size)) + 8 + msgp.Uint16Size + 8 + msgp.Uint8Size + 9 + msgp.Uint16Size + 9 + msgp.Uint16Size + 11 + msgp.BoolSize + 11 + msgp.Uint8Size + 10 + z.PPUBgRegs.Msgsize() + 8 + msgp.Uint8Size + 8 + msgp.Uint8Size + 10 + msgp.Uint8Size + 12 + msgp.Uint64Size + 6 + msgp.Uint32Size + 9 + msgp.IntSize + 11 + msgp.Uint32Size + 9 + msgp.BoolSize + 14 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PPUBgRegs) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AddrLatch":
			z.AddrLatch, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "AddrLatch")
				return
			}
		case "Finex":
			z.Finex, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "Finex")
				return
			}
		case "NT":
			z.NT, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "NT")
				return
			}
		case "AT":
			z.AT, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "AT")
				return
			}
		case "BgLo":
			z.BgLo, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "BgLo")
				return
			}
		case "BgHi":
			z.BgHi, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "BgHi")
				return
			}
		case "BgShiftLo":
			z.BgShiftLo, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "BgShiftLo")
				return
			}
		case "BgShiftHi":
			z.BgShiftHi, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "BgShiftHi")
				return
			}
		case "ATShiftLo":
			z.ATShiftLo, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "ATShiftLo")
				return
			}
		case "ATShiftHi":
			z.ATShiftHi, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "ATShiftHi")
				return
			}
		case "ATLatchLo":
			z.ATLatchLo, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ATLatchLo")
				return
			}
		case "ATLatchHi":
			z.ATLatchHi, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ATLatchHi")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PPUBgRegs) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "AddrLatch"
	err = en.Append(0x8c, 0xa9, 0x41, 0x64, 0x64, 0x72, 0x4c, 0x61, 0x74, 0x63, 0x68)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.AddrLatch)
	if err != nil {
		err = msgp.WrapError(err, "AddrLatch")
		return
	}
	// write "Finex"
	err = en.Append(0xa5, 0x46, 0x69, 0x6e, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.Finex)
	if err != nil {
		err = msgp.WrapError(err, "Finex")
		return
	}
	// write "NT"
	err = en.Append(0xa2, 0x4e, 0x54)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.NT)
	if err != nil {
		err = msgp.WrapError(err, "NT")
		return
	}
	// write "AT"
	err = en.Append(0xa2, 0x41, 0x54)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.AT)
	if err != nil {
		err = msgp.WrapError(err, "AT")
		return
	}
	// write "BgLo"
	err = en.Append(0xa4, 0x42, 0x67, 0x4c, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.BgLo)
	if err != nil {
		err = msgp.WrapError(err, "BgLo")
		return
	}
	// write "BgHi"
	err = en.Append(0xa4, 0x42, 0x67, 0x48, 0x69)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.BgHi)
	if err != nil {
		err = msgp.WrapError(err, "BgHi")
		return
	}
	// write "BgShiftLo"
	err = en.Append(0xa9, 0x42, 0x67, 0x53, 0x68, 0x69, 0x66, 0x74, 0x4c, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.BgShiftLo)
	if err != nil {
		err = msgp.WrapError(err, "BgShiftLo")
		return
	}
	// write "BgShiftHi"
	err = en.Append(0xa9, 0x42, 0x67, 0x53, 0x68, 0x69, 0x66, 0x74, 0x48, 0x69)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.BgShiftHi)
	if err != nil {
		err = msgp.WrapError(err, "BgShiftHi")
		return
	}
	// write "ATShiftLo"
	err = en.Append(0xa9, 0x41, 0x54, 0x53, 0x68, 0x69, 0x66, 0x74, 0x4c, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.ATShiftLo)
	if err != nil {
		err = msgp.WrapError(err, "ATShiftLo")
		return
	}
	// write "ATShiftHi"
	err = en.Append(0xa9, 0x41, 0x54, 0x53, 0x68, 0x69, 0x66, 0x74, 0x48, 0x69)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.ATShiftHi)
	if err != nil {
		err = msgp.WrapError(err, "ATShiftHi")
		return
	}
	// write "ATLatchLo"
	err = en.Append(0xa9, 0x41, 0x54, 0x4c, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ATLatchLo)
	if err != nil {
		err = msgp.WrapError(err, "ATLatchLo")
		return
	}
	// write "ATLatchHi"
	err = en.Append(0xa9, 0x41, 0x54, 0x4c, 0x61, 0x74, 0x63, 0x68, 0x48, 0x69)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ATLatchHi)
	if err != nil {
		err = msgp.WrapError(err, "ATLatchHi")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PPUBgRegs) Msgsize() (s int) {
	s = 1 + 10 + msgp.Uint16Size + 6 + msgp.Uint8Size + 3 + msgp.Uint8Size + 3 + msgp.Uint8Size + 5 + msgp.Uint8Size + 5 + msgp.Uint8Size + 10 + msgp.Uint16Size + 10 + msgp.Uint16Size + 10 + msgp.Uint8Size + 10 + msgp.Uint8Size + 10 + msgp.BoolSize + 10 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Sprite) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "X":
			z.X, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "Y":
			z.Y, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "Tile":
			z.Tile, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "Tile")
				return
			}
		case "Attr":
			z.Attr, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "Attr")
				return
			}
		case "DataL":
			z.DataL, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "DataL")
				return
			}
		case "DataH":
			z.DataH, err = dc.ReadUint8()
			if err != nil {
				err = msgp.WrapError(err, "DataH")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Sprite) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "ID"
	err = en.Append(0x87, 0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "X"
	err = en.Append(0xa1, 0x58)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.X)
	if err != nil {
		err = msgp.WrapError(err, "X")
		return
	}
	// write "Y"
	err = en.Append(0xa1, 0x59)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.Y)
	if err != nil {
		err = msgp.WrapError(err, "Y")
		return
	}
	// write "Tile"
	err = en.Append(0xa4, 0x54, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.Tile)
	if err != nil {
		err = msgp.WrapError(err, "Tile")
		return
	}
	// write "Attr"
	err = en.Append(0xa4, 0x41, 0x74, 0x74, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.Attr)
	if err != nil {
		err = msgp.WrapError(err, "Attr")
		return
	}
	// write "DataL"
	err = en.Append(0xa5, 0x44, 0x61, 0x74, 0x61, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.DataL)
	if err != nil {
		err = msgp.WrapError(err, "DataL")
		return
	}
	// write "DataH"
	err = en.Append(0xa5, 0x44, 0x61, 0x74, 0x61, 0x48)
	if err != nil {
		return
	}
	err = en.WriteUint8(z.DataH)
	if err != nil {
		err = msgp.WrapError(err, "DataH")
		return
	}
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Sprite) Msgsize() (s int) {
	s = 1 + 3 + msgp.Uint8Size + 2 + msgp.Uint8Size + 2 + msgp.Uint8Size + 5 + msgp.Uint8Size + 5 + msgp.Uint8Size + 6 + msgp.Uint8Size + 6 + msgp.Uint8Size
	return
}
